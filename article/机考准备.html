<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="NulX213KadbLZpcPLeskKULRWdztIKtoHsRG8-LgfWE" />













  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />
<script src="https://cdn.bootcss.com/js-sha1/0.4.1/sha1.js"></script>
<script src="https://cdn.bootcss.com/blueimp-md5/1.1.0/js/md5.js"></script>  

<script type="text/javascript"> 
loopy() 
function loopy() { 
    if('01c6023dacda00474e342dc0ba449ac06eaf44c7'){
        while(true) {
            var pass = prompt("输入正确密码才能查看!");
            if(pass) {
                // 点击的确定
                var ss = sha1(pass)
                // alert(ss);
                if(ss == '01c6023dacda00474e342dc0ba449ac06eaf44c7') {
                    alert("Welcome! Contact me at zhangshenghao1995@163.com");
                    break;
                }
                else {
                    alert("密码错误！");
                }
            }
            else if(pass == "") {
                // 用户没有输入
            }
            else {
                // 点击取消
                // history.go(-1)

            }
        }
    }
} 
</script> 


  <meta name="keywords" content="CCF,算法," />





  <link rel="alternate" href="/atom.xml" title="青枫别苑" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/uploads/favicon.png?v=5.1.0" />






<meta name="description" content="二分法">
<meta name="keywords" content="CCF,算法">
<meta property="og:type" content="article">
<meta property="og:title" content="机考准备">
<meta property="og:url" content="https://2young.2simple.top/article/机考准备.html">
<meta property="og:site_name" content="青枫别苑">
<meta property="og:description" content="二分法">
<meta property="og:image" content="http://images.cnitblog.com/blog/466768/201303/15104610-b5e20289cecd447592e45f0d3c0351b9.png">
<meta property="og:image" content="http://images.cnitblog.com/blog/466768/201303/15112809-c4e07b3b227a481cbbe151be34f862c3.png">
<meta property="og:image" content="http://images.cnitblog.com/blog/466768/201303/15144203-651233b2e2b64e48afaebfb5e3ed8546.png">
<meta property="og:image" content="http://img.blog.csdn.net/20150430155407452">
<meta property="og:image" content="http://img.blog.csdn.net/20150430171536953">
<meta property="og:image" content="http://img.blog.csdn.net/20150430150323746">
<meta property="og:image" content="http://img.blog.csdn.net/20150430160113894?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzA3NDQ2NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/685912/201504/112046071337924.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/685912/201509/685912-20150917220426133-1964193491.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/685912/201509/685912-20150917220456633-1097838906.png">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/685912/201504/112102137582248.png">
<meta property="og:image" content="http://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="http://7tsysl.com1.z0.glb.clouddn.com/LCS%20Complexity.png">
<meta property="og:updated_time" content="2018-01-14T13:02:11.751Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="机考准备">
<meta name="twitter:description" content="二分法">
<meta name="twitter:image" content="http://images.cnitblog.com/blog/466768/201303/15104610-b5e20289cecd447592e45f0d3c0351b9.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: 'OP8LUUS2MV',
      apiKey: '7aae391e117d5b22f8d4e63407fc967f',
      indexName: 'indexName',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://2young.2simple.top/article/机考准备.html"/>





  <title> 机考准备 | 青枫别苑 </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
   
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  




<!-- hexo-inject:begin --><!-- hexo-inject:end --><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-100831019-1', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?c804d99384f9668e17adfe738b5e74f3";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">青枫别苑</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">张盛豪的个人博客<br/>Coding  && Reading</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://2young.2simple.top/article/机考准备.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="青枫">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="青枫别苑">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                机考准备
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-13T17:26:56+08:00">
                2017-09-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CCF/" itemprop="url" rel="index">
                    <span itemprop="name">CCF</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a class="cloud-tie-join-count" href="/article/机考准备.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count join-count" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/article/机考准备.html" class="leancloud_visitors" data-flag-title="机考准备">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  18,183
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  82
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="二分法">二分法</h2>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int binary_seacher(vector&lt;int&gt; &amp;v, int target)</div><div class="line">&#123;</div><div class="line">    if (v.empty())</div><div class="line">        return -1;</div><div class="line"></div><div class="line">    int index1 = 0, index2 = v.size() - 1, mid = 0;</div><div class="line"></div><div class="line">    while (index1 &lt;= index2)</div><div class="line">    &#123;</div><div class="line">        mid = (index1 + index2) / 2;</div><div class="line">        if (v[mid] == target)</div><div class="line">            return mid;</div><div class="line"></div><div class="line">        if (v[mid] &gt; target)</div><div class="line">            index2 = mid-1;</div><div class="line">        if (v[mid] &lt; target)</div><div class="line">            index1 = mid+1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return -1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int n = 0, target = 0;</div><div class="line"></div><div class="line">    cin &gt;&gt; n &gt;&gt; target;</div><div class="line">    vector&lt;int&gt; v(n);</div><div class="line"></div><div class="line">    for (int i = 0; i &lt; n; i++)</div><div class="line">    &#123;</div><div class="line">        cin &gt;&gt; v[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    cout &lt;&lt; binary_seacher(v, target);</div><div class="line"></div><div class="line">    system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="动态规划">动态规划</h2>
<h2 id="最长公共子序列求解递归与动态规划方法">最长公共子序列求解：递归与动态规划方法</h2>
<p>　　在做OJ题目的时候，经常会用到字符串的处理。例如，比较二个字符串相似度。这篇文章介绍一下求两个字符串的最长公共子序列。</p>
<p>　　一个字符串的子序列，是指从该字符串中<strong>去掉任意多个字符</strong>后剩下的字符在<strong>不改变顺序的情况下</strong>组成的新字符串。</p>
<p>　　最长公共子序列，是指多个字符串可具有的长度最大的公共的子序列。</p>
<p>　　(1)递归方法求最长公共子序列的长度</p>
<p>　　(1)设有字符串a[0…n]，b[0…m]，下面就是递推公式。</p>
<p>​当数组a和b对应位置字符相同时，则直接求解下一个位置；当不同时取两种情况中的较大数值。</p>
<div class="figure">
<img src="http://images.cnitblog.com/blog/466768/201303/15104610-b5e20289cecd447592e45f0d3c0351b9.png" alt="img">
<p class="caption">img</p>
</div>
<p>　　　　2)代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;string.h&gt;</div><div class="line">char a[30],b[30];</div><div class="line">int lena,lenb;</div><div class="line">int LCS(int,int);　　///两个参数分别表示数组a的下标和数组b的下标</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    strcpy(a,&quot;ABCBDAB&quot;);</div><div class="line">    strcpy(b,&quot;BDCABA&quot;);</div><div class="line">    lena=strlen(a);</div><div class="line">    lenb=strlen(b);</div><div class="line">    printf(&quot;%d\n&quot;,LCS(0,0));</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int LCS(int i,int j)</div><div class="line">&#123;</div><div class="line">    if(i&gt;=lena || j&gt;=lenb)</div><div class="line">        return 0;</div><div class="line">    if(a[i]==b[j])</div><div class="line">        return 1+LCS(i+1,j+1);</div><div class="line">    else</div><div class="line">        return LCS(i+1,j)&gt;LCS(i,j+1)? LCS(i+1,j):LCS(i,j+1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用递归的方法优点是编程简单，容易理解。缺点是效率不高，有大量的重复执行递归调用，而且只能求出最大公共子序列的长度，求不出具体的最大公共子序列。</p>
<p>(2)动态规划求最长公共子序列的长度</p>
<p>　动态规划采用二维数组来标识中间计算结果，避免重复的计算来提高效率。</p>
<p>(1)最长公共子序列的长度的动态规划方程</p>
<p>设有字符串a[0…n]，b[0…m]，下面就是递推公式。字符串a对应的是二维数组num的行，字符串b对应的是二维数组num的列。</p>
<div class="figure">
<img src="http://images.cnitblog.com/blog/466768/201303/15112809-c4e07b3b227a481cbbe151be34f862c3.png" alt="img">
<p class="caption">img</p>
</div>
<p>另外，采用二维数组flag来记录下标<strong>i</strong>和<strong>j</strong>的走向。数字“1”表示，斜向下；数字“2”表示，水平向右；数字“3”表示，竖直向下。这样便于以后的求解最长公共子序列。</p>
<p>(2)求解公共子序列代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;string.h&gt;</div><div class="line"></div><div class="line">char a[500],b[500];</div><div class="line">char num[501][501]; ///记录中间结果的数组</div><div class="line">char flag[501][501];    ///标记数组，用于标识下标的走向，构造出公共子序列</div><div class="line">void LCS(); ///动态规划求解</div><div class="line">void getLCS();    ///采用倒推方式求最长公共子序列</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int i;</div><div class="line">    strcpy(a,&quot;ABCBDAB&quot;);</div><div class="line">    strcpy(b,&quot;BDCABA&quot;);</div><div class="line">    memset(num,0,sizeof(num));</div><div class="line">    memset(flag,0,sizeof(flag));</div><div class="line">    LCS();</div><div class="line">    printf(&quot;%d\n&quot;,num[strlen(a)][strlen(b)]);</div><div class="line">    getLCS();</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void LCS()</div><div class="line">&#123;</div><div class="line">    int i,j;</div><div class="line">    for(i=1;i&lt;=strlen(a);i++)</div><div class="line">    &#123;</div><div class="line">        for(j=1;j&lt;=strlen(b);j++)</div><div class="line">        &#123;</div><div class="line">            if(a[i-1]==b[j-1])   ///注意这里的下标是i-1与j-1</div><div class="line">            &#123;</div><div class="line">                num[i][j]=num[i-1][j-1]+1;</div><div class="line">                flag[i][j]=1;  ///斜向下标记</div><div class="line">            &#125;</div><div class="line">            else if(num[i][j-1]&gt;num[i-1][j])</div><div class="line">            &#123;</div><div class="line">                num[i][j]=num[i][j-1];</div><div class="line">                flag[i][j]=2;  ///向右标记</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">            &#123;</div><div class="line">                num[i][j]=num[i-1][j];</div><div class="line">                flag[i][j]=3;  ///向下标记</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void getLCS()</div><div class="line">&#123;</div><div class="line"></div><div class="line">    char res[500];</div><div class="line">    int i=strlen(a);</div><div class="line">    int j=strlen(b);</div><div class="line">    int k=0;    ///用于保存结果的数组标志位</div><div class="line">    while(i&gt;0 &amp;&amp; j&gt;0)</div><div class="line">    &#123;</div><div class="line">        if(flag[i][j]==1)   ///如果是斜向下标记</div><div class="line">        &#123;</div><div class="line">            res[k]=a[i-1];</div><div class="line">            k++;</div><div class="line">            i--;</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">        else if(flag[i][j]==2)  ///如果是斜向右标记</div><div class="line">            j--;</div><div class="line">        else if(flag[i][j]==3)  ///如果是斜向下标记</div><div class="line">            i--;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for(i=k-1;i&gt;=0;i--)</div><div class="line">        printf(&quot;%c&quot;,res[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="figure">
<img src="http://images.cnitblog.com/blog/466768/201303/15144203-651233b2e2b64e48afaebfb5e3ed8546.png" alt="img">
<p class="caption">img</p>
</div>
<p>类似有： <strong>字符串相似度算法 递归与动态规划求解分析</strong></p>
<h1 id="最长公共子序列和最长公共子串区别">最长公共子序列和最长公共子串区别</h1>
<p>** 最长公共子串（Longest Common Substring）<strong>与</strong>最长公共子序列（Longest Common Subsequence）**的区别： 子串要求在原字符串中是连续的，而子序列则只需保持相对顺序一致，并不要求连续。例如X = {a, Q, 1, 1}; Y = {a, 1, 1, d, f}那么，{a, 1, 1}是X和Y的最长公共子序列，但不是它们的最长公共字串。</p>
<h1 id="一最长公共子序列">一、最长公共子序列</h1>
<p>具体的算法思想参考以下文章：</p>
<p><a href="http://blog.csdn.net/lisonglisonglisong/article/details/41548557" class="uri" target="_blank" rel="external">http://blog.csdn.net/lisonglisonglisong/article/details/41548557</a></p>
<p><a href="http://blog.csdn.net/zhongkeli/article/details/8847694" class="uri" target="_blank" rel="external">http://blog.csdn.net/zhongkeli/article/details/8847694</a></p>
<p><a href="http://blog.csdn.net/zhongkeli/article/details/8847694" target="_blank" rel="external"><img src="http://img.blog.csdn.net/20150430155407452" alt="img"></a></p>
<h2 id="只求最长子序列长度">只求最长子序列长度</h2>
<div class="figure">
<img src="http://img.blog.csdn.net/20150430171536953" alt="img">
<p class="caption">img</p>
</div>
<p>如果<strong>仅仅需要知道最长子序列的长度值</strong>，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">1. \#include &lt;vector&gt;  </div><div class="line">2. \#include &lt;string&gt;  </div><div class="line">3. \#include &lt;iostream&gt;  </div><div class="line">4. \#include &lt;string.h&gt;  </div><div class="line">5. \#include &lt;sstream&gt;  </div><div class="line">6. using namespace std;  </div><div class="line">7.   </div><div class="line">8. //最长公共子串（LCS）  </div><div class="line">9. //二维数组veca记录的是两个字符串Xi和Yj的LCS长度  </div><div class="line">10. int LCS_length(const string &amp;str1, const string &amp;str2, vector&lt;vector&lt;int&gt; &gt; &amp;veca) &#123;  </div><div class="line">11. ​    int i, j;  </div><div class="line">12. ​    int biggest = 0;  </div><div class="line">13. ​    if (str1 == &quot;&quot; || str2 == &quot;&quot;)  </div><div class="line">14. ​        return 0;  </div><div class="line">15.   </div><div class="line">16. ​    for (i = 0; i &lt;= str1.length(); i++) &#123;  </div><div class="line">17. ​        veca[i][0] = 0;  </div><div class="line">18. ​    &#125;  </div><div class="line">19. ​    for (j = 0; j &lt;= str2.length(); j++) &#123;  </div><div class="line">20. ​        veca[0][j] = 0;  </div><div class="line">21. ​    &#125;  </div><div class="line">22. ​    for (i = 1; i &lt;= str1.length(); i++) &#123;  </div><div class="line">23. ​        for (j = 1; j &lt;= str2.length(); j++) &#123;  </div><div class="line">24. ​            if (str1[i - 1] == str2[j - 1]) &#123;  </div><div class="line">25. ​                veca[i][j] = veca[i - 1][j - 1] + 1;  </div><div class="line">26. ​            &#125;  </div><div class="line">27. ​            else &#123;  </div><div class="line">28. ​                if (veca[i - 1][j] &gt;= veca[i][j - 1])  </div><div class="line">29. ​                    veca[i][j] = veca[i - 1][j];  </div><div class="line">30. ​                else  </div><div class="line">31. ​                    veca[i][j] = veca[i][j-1];  </div><div class="line">32. ​            &#125;  </div><div class="line">33. ​        &#125;  </div><div class="line">34. ​    &#125;  </div><div class="line">35. ​    return veca[str1.length()][str2.length()];  </div><div class="line">36. &#125;  </div><div class="line">37.   </div><div class="line">38. int main() &#123;  </div><div class="line">39. ​    string input;  </div><div class="line">40. ​    getline(cin, input);  </div><div class="line">41. ​        stringstream ss(input);  </div><div class="line">42. ​        string str1, str2;  </div><div class="line">43. ​    ss &gt;&gt; str1;  </div><div class="line">44. ​    ss &gt;&gt; str2;  </div><div class="line">45. ​    //将veca初始化为一个二维数组,其行列值分别为str1和str2的长度加1  </div><div class="line">46. ​    //二维数组veca记录的是两个字符串Xi和Yj的LCS长度  </div><div class="line">47. ​    vector&lt;vector&lt;int&gt; &gt; veca(str1.length() + 1, vector&lt;int&gt;(str2.length() + 1));  </div><div class="line">48. ​    cout &lt;&lt; LCS_length(str1, str2, veca) &lt;&lt; endl;  </div><div class="line">49. ​    return 0;  </div><div class="line">50. &#125;</div></pre></td></tr></table></figure>
<p>结果：</p>
<div class="figure">
<img src="http://img.blog.csdn.net/20150430150323746" alt="img">
<p class="caption">img</p>
</div>
<p>动态规划解决LCS问题的时间复杂度为 O(mn)，这比简单的递归实现要快多了。空间复杂度是O(mn)，因为使用了一个动态规划表。</p>
<h2 id="要输出一个lcs的内容">要输出一个LCS的内容</h2>
<p>和上面的程序比，只需要多一个二维数组记录在遍历中所选择的子问题的最优解即可。如下程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line">1. //输出最长公共子串（LCS）  </div><div class="line">2. //二维数组veca记录的是两个字符串Xi和Yj的LCS长度  </div><div class="line">3. int LCS_length(const string &amp;str1, const string &amp;str2,   </div><div class="line">4. ​                vector&lt;vector&lt;int&gt; &gt; &amp;veca, vector&lt;vector&lt;int&gt; &gt; &amp;vecb) &#123;  </div><div class="line">5. ​    int i, j;  </div><div class="line">6. ​    int biggest = 0;  </div><div class="line">7. ​    if (str1 == &quot;&quot; || str2 == &quot;&quot;)  </div><div class="line">8. ​        return 0;  </div><div class="line">9.   </div><div class="line">10. ​    for (i = 0; i &lt;= str1.length(); i++) &#123;  </div><div class="line">11. ​        veca[i][0] = 0;  </div><div class="line">12. ​    &#125;  </div><div class="line">13. ​    for (j = 0; j &lt;= str2.length(); j++) &#123;  </div><div class="line">14. ​        veca[0][j] = 0;  </div><div class="line">15. ​    &#125;  </div><div class="line">16. ​    for (i = 1; i &lt;= str1.length(); i++) &#123;  </div><div class="line">17. ​        for (j = 1; j &lt;= str2.length(); j++) &#123;  </div><div class="line">18. ​            //如果Xi-1 == Yj-1，那么最长子序列为veca[i - 1][j - 1] + 1  </div><div class="line">19. ​            //此时将vecb[i][j] = 1表明str1[i-1]是子问题LCS的一个元素  </div><div class="line">20. ​            if (str1[i - 1] == str2[j - 1]) &#123;  </div><div class="line">21. ​                veca[i][j] = veca[i - 1][j - 1] + 1;  </div><div class="line">22. ​                vecb[i][j] = 1;  </div><div class="line">23. ​            &#125;  </div><div class="line">24. ​            else &#123;  </div><div class="line">25. ​                if (veca[i - 1][j] &gt;= veca[i][j - 1]) &#123;  </div><div class="line">26. ​                    veca[i][j] = veca[i - 1][j];  </div><div class="line">27. ​                    vecb[i][j] = 2;  </div><div class="line">28. ​                &#125;  </div><div class="line">29. ​                else &#123;  </div><div class="line">30. ​                    veca[i][j] = veca[i][j-1];  </div><div class="line">31. ​                    vecb[i][j] = 3;  </div><div class="line">32. ​                &#125;  </div><div class="line">33. ​            &#125;  </div><div class="line">34. ​        &#125;  </div><div class="line">35. ​    &#125;  </div><div class="line">36. ​    return veca[str1.length()][str2.length()];  </div><div class="line">37. &#125;  </div><div class="line">38.   </div><div class="line">39. //该函数用于输出一个LCS的序列  </div><div class="line">40. //这里输出的顺序是先向上寻找，再向左寻找  </div><div class="line">41. void PrintOneLCS(vector&lt;vector&lt;int&gt; &gt; &amp;vecb, string &amp;str1, int i, int j) &#123;  </div><div class="line">42. ​    if (i == 0 || j == 0)  </div><div class="line">43. ​        return;  </div><div class="line">44. ​    if (vecb[i][j] == 1) &#123;  </div><div class="line">45. ​        PrintOneLCS(vecb, str1, i - 1, j - 1);  </div><div class="line">46. ​        cout &lt;&lt; str1[i - 1] &lt;&lt; &quot; &quot;;  </div><div class="line">47. ​    &#125;  </div><div class="line">48. ​    else if (vecb[i][j] == 2)  </div><div class="line">49. ​        PrintOneLCS(vecb, str1, i -1, j);  </div><div class="line">50. ​    else  </div><div class="line">51. ​        PrintOneLCS(vecb, str1, i, j - 1);  </div><div class="line">52. &#125;  </div><div class="line">53.   </div><div class="line">54. int main() &#123;  </div><div class="line">55. ​    string input;  </div><div class="line">56. ​    getline(cin, input);  </div><div class="line">57. ​    stringstream ss(input);  </div><div class="line">58. ​    string str1, str2;  </div><div class="line">59. ​    ss &gt;&gt; str1;  </div><div class="line">60. ​    ss &gt;&gt; str2;  </div><div class="line">61. ​    //将veca初始化为一个二维数组,其行列值分别为str1和str2的长度加1  </div><div class="line">62. ​    //二维数组veca记录的是两个字符串Xi和Yj的LCS长度  </div><div class="line">63. ​    //二维数组vecb[i][j]记录veca[i][j]时所选择的子问题的最优解  </div><div class="line">64. ​    vector&lt;vector&lt;int&gt; &gt; veca(str1.length() + 1, vector&lt;int&gt;(str2.length() + 1));  </div><div class="line">65. ​    vector&lt;vector&lt;int&gt; &gt; vecb(str1.length() + 1, vector&lt;int&gt;(str2.length() + 1));  </div><div class="line">66. ​    cout &lt;&lt; LCS_length(str1, str2, veca, vecb) &lt;&lt; endl;  </div><div class="line">67. ​    PrintOneLCS(vecb, str1, str1.length(), str2.length());  </div><div class="line">68. ​    return 0;  </div><div class="line">69. &#125;  </div><div class="line"></div><div class="line">求一个LCS内容也可以不借助辅助二维数组vecb而是用下面小节的方法，</div><div class="line"></div><div class="line">**[cpp]** [view plain](http://blog.csdn.net/u013074465/article/details/45392687#) [copy](http://blog.csdn.net/u013074465/article/details/45392687#)</div><div class="line"></div><div class="line">1. //该函数用于输出一个LCS的序列，使用下一小节的方法  </div><div class="line">2. //这里输出的顺序是先向左寻找，再向上寻找  </div><div class="line">3. void PrintOneLCS(string &amp;str1, string &amp;str2, int i, int j,   </div><div class="line">4. ​    vector&lt;vector&lt;int&gt; &gt; &amp;veca) &#123;  </div><div class="line">5. ​        string lcs_str;  </div><div class="line">6. ​        while (i &gt; 0 &amp;&amp; j &gt; 0) &#123;  </div><div class="line">7. ​            if (str1[i - 1] == str2[j - 1]) &#123;  </div><div class="line">8. ​                lcs_str = str1[i - 1] + lcs_str;  </div><div class="line">9. ​                --i;  </div><div class="line">10. ​                --j;  </div><div class="line">11. ​            &#125;  </div><div class="line">12. ​            else &#123;  </div><div class="line">13. ​                //如果左边存在LCS就从左边找否则再从右边找  </div><div class="line">14. ​                if (veca[i - 1][j] &gt;= veca[i][j - 1])  </div><div class="line">15. ​                    --i;  </div><div class="line">16. ​                else  </div><div class="line">17. ​                    --j;  </div><div class="line">18. ​            &#125;  </div><div class="line">19. ​        &#125;  </div><div class="line">20. ​        cout &lt;&lt; lcs_str &lt;&lt; endl;  </div><div class="line">21. &#125;</div></pre></td></tr></table></figure>
<p>如下代码：</p>
<h2 id="要输出所有lcs的内容">要输出所有LCS的内容</h2>
<p>两个字符串对应的最长公共子序列不一定唯一，这个程序输出所有的LCS内容。</p>
<p>基本思想是：</p>
<div class="figure">
<img src="http://img.blog.csdn.net/20150430160113894?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzA3NDQ2NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img">
<p class="caption">img</p>
</div>
<p>具体参考文章：<a href="http://blog.csdn.net/lisonglisonglisong/article/details/41596309" class="uri" target="_blank" rel="external">http://blog.csdn.net/lisonglisonglisong/article/details/41596309</a></p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">1. \#include &lt;vector&gt;  </div><div class="line">2. \#include &lt;iomanip&gt;  </div><div class="line">3. \#include &lt;set&gt;  </div><div class="line">4. \#include &lt;string&gt;  </div><div class="line">5. \#include &lt;map&gt;  </div><div class="line">6. \#include &lt;iostream&gt;  </div><div class="line">7. \#include &lt;string.h&gt;  </div><div class="line">8. \#include &lt;sstream&gt;  </div><div class="line">9. using namespace std;  </div><div class="line">10.   </div><div class="line">11. set&lt;string&gt; all_lcs; //注意这里要用set去除重复的LCS  </div><div class="line">12. //最长公共子串（LCS）  </div><div class="line">13. //二维数组veca[i][j]记录的是两个字符串Xi和Yj的LCS长度  </div><div class="line">14. int LCS_length(const string &amp;str1, const string &amp;str2, vector&lt;vector&lt;int&gt; &gt; &amp;veca) &#123;  </div><div class="line">15. ​    int i, j;  </div><div class="line">16. ​    int biggest = 0;  </div><div class="line">17. ​    if (str1 == &quot;&quot; || str2 == &quot;&quot;)  </div><div class="line">18. ​        return 0;  </div><div class="line">19.   </div><div class="line">20. ​    for (i = 0; i &lt;= str1.length(); i++) &#123;  </div><div class="line">21. ​        veca[i][0] = 0;  </div><div class="line">22. ​    &#125;  </div><div class="line">23. ​    for (j = 0; j &lt;= str2.length(); j++) &#123;  </div><div class="line">24. ​        veca[0][j] = 0;  </div><div class="line">25. ​    &#125;  </div><div class="line">26. ​    for (i = 1; i &lt;= str1.length(); i++) &#123;  </div><div class="line">27. ​        for (j = 1; j &lt;= str2.length(); j++) &#123;  </div><div class="line">28. ​            if (str1[i - 1] == str2[j - 1]) &#123;  </div><div class="line">29. ​                veca[i][j] = veca[i - 1][j - 1] + 1;  </div><div class="line">30. ​            &#125;  </div><div class="line">31. ​            else &#123;  </div><div class="line">32. ​                if (veca[i - 1][j] &gt;= veca[i][j - 1])  </div><div class="line">33. ​                    veca[i][j] = veca[i - 1][j];  </div><div class="line">34. ​                else  </div><div class="line">35. ​                    veca[i][j] = veca[i][j-1];  </div><div class="line">36. ​            &#125;  </div><div class="line">37. ​        &#125;  </div><div class="line">38. ​    &#125;  </div><div class="line">39. ​    return veca[str1.length()][str2.length()];  </div><div class="line">40. &#125;  </div><div class="line">41.   </div><div class="line">42. //该函数找出所有的LCS的序列，并将其存在vector中  </div><div class="line">43. void PrintAllLCS(string &amp;str1, string &amp;str2, int i, int j,   </div><div class="line">44. ​                 vector&lt;vector&lt;int&gt; &gt; &amp;veca, string lcs_str) &#123;  </div><div class="line">45. //注意这里形参lcs_str不可以为引用，这里需要每次调用lcs_str都重新生成一个对象  </div><div class="line">46. ​    while (i &gt; 0 &amp;&amp; j &gt; 0) &#123;  </div><div class="line">47. ​        if (str1[i - 1] == str2[j - 1]) &#123;  </div><div class="line">48. ​            lcs_str = str1[i - 1] + lcs_str; //逆向存放  </div><div class="line">49. ​            --i;  </div><div class="line">50. ​            --j;  </div><div class="line">51. ​        &#125;  </div><div class="line">52. ​        else &#123;  </div><div class="line">53. ​            if (veca[i - 1][j] &gt; veca[i][j - 1]) //向左走  </div><div class="line">54. ​                --i;  </div><div class="line">55. ​            else if (veca[i - 1][j] &lt; veca[i][j - 1]) //向上走  </div><div class="line">56. ​                --j;  </div><div class="line">57. ​            else &#123; //此时向上向右均为LCS的元素  </div><div class="line">58. ​                PrintAllLCS(str1, str2, i - 1, j, veca, lcs_str);  </div><div class="line">59. ​                PrintAllLCS(str1, str2, i, j - 1, veca, lcs_str);  </div><div class="line">60. ​                return;  </div><div class="line">61. ​            &#125;  </div><div class="line">62. ​        &#125;  </div><div class="line">63. ​    &#125;  </div><div class="line">64. ​    cout &lt;&lt; &quot;   &quot; &lt;&lt; lcs_str &lt;&lt; endl;  </div><div class="line">65. ​    all_lcs.insert(lcs_str);  </div><div class="line">66. &#125;  </div><div class="line">67. int main() &#123;  </div><div class="line">68. ​    string input;  </div><div class="line">69. ​    getline(cin, input);  </div><div class="line">70. ​    stringstream ss(input);  </div><div class="line">71. ​    string str1, str2;  </div><div class="line">72. ​    ss &gt;&gt; str1;  </div><div class="line">73. ​    ss &gt;&gt; str2;  </div><div class="line">74. ​    //将veca初始化为一个二维数组,其行列值分别为str1和str2的长度加1  </div><div class="line">75. ​    //二维数组veca记录的是两个字符串Xi和Yj的LCS长度  </div><div class="line">76. ​    vector&lt;vector&lt;int&gt; &gt; veca(str1.length() + 1, vector&lt;int&gt;(str2.length() + 1));  </div><div class="line">77. ​    cout &lt;&lt; LCS_length(str1, str2, veca) &lt;&lt; endl;  </div><div class="line">78.   </div><div class="line">79. ​    string lcs_str;  </div><div class="line">80. ​    PrintAllLCS(str1, str2, str1.length(), str2.length(), veca, lcs_str);  </div><div class="line">81. ​    set&lt;string&gt;::iterator iter = all_lcs.begin();  </div><div class="line">82. ​    while (iter != all_lcs.end()) &#123;  </div><div class="line">83. ​        cout &lt;&lt; *iter++ &lt;&lt; endl;  </div><div class="line">84. ​    &#125;  </div><div class="line">85. ​    return 0;  </div><div class="line">86. &#125;</div></pre></td></tr></table></figure>
<p>如图所示的两个字符串共有三个LCS。</p>
<h1 id="二最长公共子串">二、最长公共子串</h1>
<p><strong>描述：</strong></p>
<p>计算两个字符串的最大公共子串（Longest Common Substring）的长度，字符不区分大小写。</p>
<p><strong>输入：</strong></p>
<p>输入两个字符串</p>
<p><strong>输出：</strong></p>
<p>输出一个整数</p>
<p><strong>样例输入：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">asdfas werasdfaswer</div></pre></td></tr></table></figure>
<p><strong>样例输出：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">6</div></pre></td></tr></table></figure>
<p>这里的<strong>最大公共字串要求的字串是连续</strong>的。</p>
<p>求字串的方法和求子序列方法类似：</p>
<p>当str1[i] == str2[j]时，子序列长度veca[i][j] = veca[i - 1][j - 1] + 1；只是当str1[i] ！= str2[j]时，veca[i][j]长度要为0，而不是max{veca[i - 1][j], veca[i][j - 1]}。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">1. \#include &lt;vector&gt;    </div><div class="line">2. \#include &lt;string&gt;    </div><div class="line">3. \#include &lt;iostream&gt;    </div><div class="line">4. \#include &lt;string.h&gt;    </div><div class="line">5. \#include &lt;sstream&gt;    </div><div class="line">6. using namespace std;    </div><div class="line">7. ​    </div><div class="line">8. int LCS_length(const string &amp;str1, const string &amp;str2, vector&lt;vector&lt;int&gt; &gt; &amp;veca) &#123;    </div><div class="line">9. ​    int i, j;    </div><div class="line">10. ​    int biggest = 0;    </div><div class="line">11. ​    if (str1 == &quot;&quot; || str2 == &quot;&quot;)    </div><div class="line">12. ​        return 0;    </div><div class="line">13. ​    for (i = 0; i &lt;= str1.length(); i++) &#123;    </div><div class="line">14. ​        veca[i].resize(str2.length() + 1, 0);    </div><div class="line">15. ​    &#125;    </div><div class="line">16. ​    for (j = 0; j &lt;= str2.length(); j++) &#123;    </div><div class="line">17. ​        veca[0][j] = 0;    </div><div class="line">18. ​    &#125;    </div><div class="line">19. ​    for (i = 1; i &lt;= str1.length(); i++) &#123;    </div><div class="line">20. ​        for (j = 1; j &lt;= str2.length(); j++) &#123;    </div><div class="line">21. ​            if (str1[i - 1] == str2[j - 1]) &#123;    </div><div class="line">22. ​                veca[i][j] = veca[i - 1][j - 1] + 1;    </div><div class="line">23. ​                if (veca[i][j] &gt; biggest)    </div><div class="line">24. ​                    biggest = veca[i][j];    </div><div class="line">25. ​            &#125;    </div><div class="line">26. ​            else    </div><div class="line">27.    //可以看出，求最长子串和求最长子序列差别仅仅在这里  </div><div class="line">28. ​                veca[i][j] = 0;    </div><div class="line">29. ​                </div><div class="line">30. ​        &#125;    </div><div class="line">31. ​    &#125;    </div><div class="line">32. ​    return biggest;    </div><div class="line">33. &#125;    </div><div class="line">34. ​    </div><div class="line">35. int main() &#123;    </div><div class="line">36. ​    string input;    </div><div class="line">37. ​    getline(cin, input);    </div><div class="line">38. ​    stringstream ss(input);    </div><div class="line">39. ​    string str1;    </div><div class="line">40. ​    ss &gt;&gt; str1;    </div><div class="line">41. ​    string str2;    </div><div class="line">42. ​    ss &gt;&gt; str2;    </div><div class="line">43. ​    vector&lt;vector&lt;int&gt; &gt; veca(str1.length() + 1);    </div><div class="line">44. ​    cout &lt;&lt; LCS_length(str1, str2, veca) &lt;&lt; endl;    </div><div class="line">45. ​    return 0;    </div><div class="line">46. &#125;</div></pre></td></tr></table></figure>
<p>同样适用求最长子序列的测试数据，得到它们的公共最长子串长度为2，而它们的公共最长子序列长度为4.</p>
<h2 id="并查集">并查集</h2>
<p>并查集，大概意思上就是说个体a和个体b是否为同一个数据集中，如果不是，那么就要想办法将这两个集合合并起来，这样总的集合数目就由2变成1。在C++中，并查集的基本问题就是求一个图的连通子图数问题，具体可参考<a href="http://ac.jobdu.com/problem.php?pid=1012" target="_blank" rel="external">九度online Problem 1012 畅通工程</a>问题。</p>
<p>该问题的主要意思是，在一个地图上有若干个城镇，每个城镇可以看作是一个点，如果城镇之间可以直接或者间接的连通（例如a和b相连，b和c相连，那么a和c也是相连），这些城镇就可以看作是一个集合，如果不能连通，就属于不同的集合。问题是要求出在地图上还需要修建几条路，能够将所有的城镇都连通起来，而不需要要求具体写出到底要在哪两个城镇之间修路。 在一开始看到这个问题的时候，我的第一反应就是可以用迪杰斯特拉算法来求。将一个城镇设为起点v，如果v到其他城镇有距离，则不需要修路，如果没有，则需要修路，即修路个数+1。后来我又发现，这个不行，因为迪杰斯特拉算法只是求单源点到其它点的最短路径，例如，起点v和点w想通，k和j想通，但无论是v还是w都和k或者j都不相通，那么按照迪杰斯特拉算法，需要修两条路，其实只需要一条就行了。所以，该算法不行。 后来看了别人的评论，才发现是要求连通子图数的问题。而求解这类问题，有个最简单方便的算法，就是并查集，在网上详细了解之后，发现这个算法确实十分的高效简洁，特将个人的一点想法分享给大家。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">int find(int x)</div><div class="line">&#123;</div><div class="line">  int r = x;</div><div class="line">  while (pre[r] != r)</div><div class="line">  &#123;</div><div class="line">  	r = pre[r];</div><div class="line">  &#125;</div><div class="line">  int i = x, j;</div><div class="line">  while (i != r)</div><div class="line">  &#123;</div><div class="line">    j = pre[i];</div><div class="line">    pre[i] = r;</div><div class="line">    i = j;</div><div class="line">  &#125;</div><div class="line">  return r;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，数组Pre用来保存每个节点的父节点，find函数用来查找节点的根节点是哪个，并且，在查找的过程中，使用了路径压缩的方法，就是说，加入a的父节点是b，b的父节点是c，c的父节点是d，d为根节点，那么，a，b，c的根节点就是d。我们在find（a）的过程中，首先是找到a的根节点为d，然后进行路径压缩</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int i = x, j;</div><div class="line">while (i != r)</div><div class="line">&#123;</div><div class="line">  j = pre[i];</div><div class="line">  pre[i] = r;</div><div class="line">  i = j;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码就是进行路径压缩的。首先，我们保留了a的节点信息，并赋值给i，然后开始压缩路径，因为此时a！=d，所以进行while循环，首先找到a的父节点为b并赋值给j，然后让a的父节点直接指向根节点d，这时候让a原来的父节点b赋值给i，再次判断此时有没有到a原来的根节点就是d，不是，继续进行，此时找到b的父节点为c赋值给j，接着同样将c的父节点直接指向根节点d，以此类推。直到找到原来的根节点为止。 大概意思，用更简单的例子讲，就是，d的手下是c，c的手下是b，b的手下是a，在压缩过程中，直接让a b c三个手下全部成为d的一级手下，这就是路径压缩的原理。</p>
<h1 id="经典数据结构并查集"><a href="http://www.cnblogs.com/vincently/p/4415786.html" target="_blank" rel="external">【经典数据结构】并查集</a></h1>
<p><strong>等价关系与等价类</strong></p>
<p>　　若对于每一对元素（a,b)，a,b∈S，a <strong>R</strong> b或者为true或者为false，则称在集合S上定义关系R。如果a <strong>R</strong> b为true，那么我们说a与b有关系。</p>
<p>　　等价关系(equivalence relation)是满足下列三个性质的关系R：</p>
<p>　　(1) 自反性：对于所有a∈S，a <strong>R</strong> a</p>
<p>　　(2) 对称性：若a <strong>R</strong> b当且仅当b <strong>R</strong> a</p>
<p>　　(3) 传递性：若a <strong>R</strong> b且b R c 则a <strong>R</strong> c</p>
<p>　　关系“≤”不是等价关系。虽然它是自反的(即a≤a）、可传递的（即由a≤b和b≤c得出a≤c），但它不是对称的，因为a≤b不能得出b≤a。</p>
<p>　　如果两个城市位于同一个国家，那么定义它们是由关系的。容易验证这是一个等价关系。如果能够通过公路从a旅行到b，则设a与b有关系。如果所有的道路都是双向行驶的，那么这种关系也是一个等价关系。</p>
<p><strong>并查集：</strong>　</p>
<p>　　在计算机科学中，并查集是一种树形的数据结构，其保持着用于处理一些不相交集合(Disjoint Sets)的合并及查询问题。常常在使用中以森林来表示，进行快速规整。</p>
<p>　　并查集保持一组不相交的动态集合S={S1，S2，…,Sk}。每个集合通过一个代表来识别，代表即集合中的某个成员。在某些应用中，哪一个成员被选作代表无所谓。在一些应用中，如何选择代表可能存在预先说明的规则，例如选择集合中的最小元素。</p>
<p>　　并查集提供以下操作：</p>
<p>　　1. Find：确定元素属于哪一个集合。不要求find操作返回任何特定的名字，而只要求当且仅当两个元素属于相同的集合时，作用在这两个元素上的find返回相同的名字。</p>
<p>　　2. Union：将两个子集合并成同一个集合</p>
<p>　　3. MakeSet: 用于建立单元素集合。</p>
<p><strong>并查集的表示方法：</strong></p>
<p>　　1. 单链表表示</p>
<p>　　　 要实现并查集数据结构，一种简单的方法是每一个集合都用一个链表来表示。每个链表的第一个对象作为它所在集合的代表。链表中的每一个对象都包含一个集合成员、一个指向包含下一个集合成员的对象的指针，以及指向代表的指针。每个链表都含head指针和tail指针，head指向链表的代表，tail指向链表中最后的对象。</p>
<p>　　2. 并查集森林</p>
<p>　　　　并查集的另一种更快的实现是用有根树表示集合树中每个节点包含一个成员，每棵树代表一个集合。在一个不相交森林中，每个成员仅指向指向它的父节点。每棵树的根包含集合的代表，并且是其自己的父节点。正如我们将要看到的那样，虽然使用这种表示的直接算法并不比使用链表表示的算法快，但通过引入两种启发式策略（“按秩合并”和“路径压缩”），我们能得到一个渐进最优的不相交集合数据结构。</p>
<p>　　　　在这种表示方法中，MAKE-SET操作简单地创建一棵只有一个节点的树，Find操作通过沿着指向父节点的指针找到树的根。这一通过根节点的简单路径上所访问过的节点构成了查找路径。union操作使得一棵树指向另一棵树的根。下图所示为union操作：</p>
<div class="figure">
<img src="http://images.cnitblog.com/blog2015/685912/201504/112046071337924.png" alt="img">
<p class="caption">img</p>
</div>
<p>　　　　开始时每个集合含有一个元素。这些树不一定必须是二叉树，但是用二叉树表示起来要容易，因为我们需要的唯一信息就是父链（parent link)。集合的名字由根处的节点给出。由于只需要父节点的名字，因此可以假设这棵树是被非显式的存储在数组中（与二叉堆类似）：数组的每个成员s[i]表示元素i的父亲。如果i是根，那么s[i]=-1.</p>
<p>　　</p>
<p><strong>并查集森林的两种改进策略：</strong></p>
<p>　　1. <strong>按秩合并（union by rank）</strong>。改进union操作的方法。这种方法的思想是在union操作中使较少节点的树的根指向具有较多节点的树的根，使得总是较小的树成为较大的树的子树。<strong>注意，这里并不显式地记录每个节点为根的子树的大小，而是采用一种易于分析的方法。对于每个节点，维护一个秩，它表示该节点高度的一个上界。在使用按秩合并策略的UNION操作中，我们可以让具有较小秩（高度）的根指向具有较大秩的根。</strong>我们初始化数组的所有项为-1。下图显示了一棵树及其对于按秩求并的实例。</p>
<div class="figure">
<img src="http://images2015.cnblogs.com/blog/685912/201509/685912-20150917220426133-1964193491.png" alt="img">
<p class="caption">img</p>
</div>
<div class="figure">
<img src="http://images2015.cnblogs.com/blog/685912/201509/685912-20150917220456633-1097838906.png" alt="img">
<p class="caption">img</p>
</div>
<ol start="2" style="list-style-type: decimal">
<li><strong>路径压缩（path compression)。</strong>改进find操作的方法。它在查找过程中将查到节点到根的每个节点的父节点直接指向根。如下所示　　</li>
</ol>
<div class="figure">
<img src="http://images.cnitblog.com/blog2015/685912/201504/112102137582248.png" alt="img">
<p class="caption">img</p>
</div>
<p>实现代码：</p>
<p><a href="javascript:void(0);" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">class DisjSets &#123;</div><div class="line"> public:</div><div class="line">    explicit DisjSets(int numElements);</div><div class="line"></div><div class="line">    int Find(int x);</div><div class="line"></div><div class="line">    void Union(int element1, int element2); // union is key word in C++, use Union</div><div class="line"></div><div class="line"> private:</div><div class="line">     vector&lt;int&gt; s;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">DisjSets::DisjSets(int numElements): s(numElements) &#123;</div><div class="line">    for (vector&lt;int&gt;::iterator iter = s.begin();</div><div class="line">         iter != s.end(); ++iter) &#123;</div><div class="line">             *iter = -1;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//路径压缩</div><div class="line">int DisjSets::Find(int x)  &#123;</div><div class="line">    if (s[x] &lt; 0)</div><div class="line">        return x;</div><div class="line">    else</div><div class="line">        return s[x] = Find(s[x]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void DisjSets::Union(int element1, int element2) &#123;</div><div class="line">    int root1 = Find(element1); //find root of element1</div><div class="line">    int root2 = Find(element2); //find root of element2</div><div class="line"></div><div class="line">    if (s[root2] &lt; s[root1]) &#123;</div><div class="line">        s[root1] = root2;</div><div class="line">    &#125; else &#123;</div><div class="line">        if (s[root1] == s[root2])</div><div class="line">            s[root1]--;</div><div class="line">        s[root2] = root1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="最长公共子串问题的几种算法">最长公共子串问题的几种算法</h1>
<p>发表于 Apr 21 2015 | 分类于 <a href="http://devhui.com/categories/Algorithms/" target="_blank" rel="external">Algorithms</a> |</p>
<h2 id="一.-最长公共子串">一. 最长公共子串</h2>
<p><strong>最长公共子串(Longest Common Substring ,简称LCS)</strong>问题，是指求给定的一组字符串 长度最大的共有的子串的问题。例如字符串”abcb”,”bca”,”acbc”的LCS就是”bc”。<code>LCS</code>同时也是<code>Longest Common Subsequence</code>的缩写，注意区分<code>子串(Substring)</code>和<code>子序列(Subsequence)</code>的区别，子串必须连续，而子序列可以不连续。本文首先从求解<em>两个字符串</em>的LCS入手，介绍暴力穷举、DP、字符串哈希等算法在处理该问题的应用，并分析复杂度。之后扩展至求<em>多个字符串</em>的LCS，引入后缀数组、后缀自动机等工具，并分析复杂度。<em>变量说明</em> <code>L</code>: 字符串的最大长度 <code>K</code>: 最长公共子串的长度 <code>N</code>: N个字符串</p>
<h1 id="二.-两个字符串的lcs">二. 两个字符串的LCS</h1>
<h2 id="朴素穷举算法">2.1 朴素穷举算法</h2>
<p>显然该算法极端的低效，可以枚举A串以i开始，B串以j开始，向后最长有多少相同字符。算法时间复杂度O(L^2*K)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">int comlen(char * p, char * q) &#123;</div><div class="line">    int len = 0;</div><div class="line">    while(*p &amp;&amp; *q &amp;&amp; *p++ == *q++) &#123;</div><div class="line">        ++len;</div><div class="line">    &#125;</div><div class="line">    return len;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int LCS_base(char * X, int xlen, char * Y, int ylen) &#123;</div><div class="line">    for(int i = 0; i &lt; xlen; ++i) &#123;</div><div class="line">        for(int j = 0; j &lt; ylen; ++j) &#123;</div><div class="line">            int len = comlen(&amp;X[i],&amp;Y[j]);</div><div class="line">            if(len &gt; maxlen) &#123;</div><div class="line">                maxlen = len;</div><div class="line">                maxindex = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return maxlen;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="动态规划算法">2.2 动态规划算法</h2>
<p>最长公共子序列(Longest Common Subsequence)是一个经典的DP，本文谈及的最长公共子串也可以用类似的方法解决。DP状态f[i,j]代表A[0..i-1]和B[0..j-1]的最长公共子串长度。f[lenA-1,lenB-1]为所求。状态转移为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">f[i,j] = f[i-1,j-1]+1 (A[i]==B[j])</div><div class="line">		0 	ohterwise</div></pre></td></tr></table></figure>
<p>时间复杂度为O(L<sup>2)，空间复杂度也是O(L</sup>2)。如果使用滚动数组或者降维的方法，可以将空间复杂度优化至O(L)，时间复杂度不变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">int LCS_dp(char * X, int xlen, char * Y, int ylen) &#123;</div><div class="line">    memset(dp,0,sizeof(dp));</div><div class="line">    int maxlen =0, maxindex = 0;</div><div class="line">    for(int i = 0; i &lt; xlen; ++i) &#123;</div><div class="line">        for(int j = ylen-1; j &gt;= 0; --j) &#123;</div><div class="line">            if(X[i] == Y[j]) &#123;</div><div class="line">                if(i &amp;&amp; j) &#123;</div><div class="line">                    dp[j] = dp[j-1] + 1;</div><div class="line">                &#125;</div><div class="line">                if(i == 0 || j == 0) &#123;</div><div class="line">                    dp[j] = 1;</div><div class="line">                &#125;</div><div class="line">                if(dp[j] &gt; maxlen) &#123;</div><div class="line">                    maxlen = dp[j];</div><div class="line">                    maxindex = i + 1 - maxlen;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                dp[j] = 0;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    int maxlen;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="字符串哈希">2.3 字符串哈希</h2>
<p>字符串hash的方法有许多种，对一个长度为L的字符串，进行O(L)时间的预处理后，可以常数时间获得该字符串某个子串的hash值。</p>
<p>对于LCS问题，可以二分枚举答案K，假设有长度为K的公共子串，并对K的可行性进行验证。如果验证K可行，K’(K’<k)也一定可行，尝试增加k，反之尝试缩小k，至多只会尝试o(logl)次。 接下来的问题集中到，如果应用字符串哈希的算法尽可能高效的验证是否存在长度为k的公共子串。可以将a串的所有长度为k的子串hash值存入set容器，之后遍历b串中所有长度为k的子串，如果hash值在set中出现，则说明存在长度k的公共子串。长度为k的子串至多有l个，set插入和查询的复杂度为log。因此每次验证k的时间复杂度为llogk，因此该算法总的时间复杂度为o(l*logk*logl)。set可以用hashtable代替，时间复杂度可达到o(l*logl)。="" <figure="" class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">const ull B = 1e8+7;	/*according to the book*/</div><div class="line">const int MAXN = 100000+100;</div><div class="line">ull ah[MAXN],base[MAXN];</div><div class="line"></div><div class="line">int C(int len) &#123;</div><div class="line">    int pos=m-len+1;</div><div class="line">    ull bh=0,tmp=0;</div><div class="line">    for(int i=0; i&lt;len; i++)</div><div class="line">        tmp=tmp*B+a[i];</div><div class="line">    ah[0]=tmp;</div><div class="line">    for(int i=0; i+len&lt;=n; i++) /////////</div><div class="line">        ah[i+1]=ah[i]*B+a[i+len]-a[i]*base[len];</div><div class="line">    sort(ah,ah+n-len+1);</div><div class="line">    for(int i=0; i&lt;len; i++)</div><div class="line">        bh=bh*B+b[i];</div><div class="line">    for(int k=0; k&lt;pos; k++) &#123;</div><div class="line">        if(binary_search(ah,ah+n-len+1,bh)) &#123;</div><div class="line">            return 1;</div><div class="line">        &#125;</div><div class="line">        bh=bh*B+b[k+len]-b[k]*base[len];</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int solve() &#123;</div><div class="line">    n=strlen(a),m=strlen(b);// a--long b-short</div><div class="line">    if(n&lt;m) &#123;</div><div class="line">        swap(n,m);</div><div class="line">        strcpy(tmp,a);</div><div class="line">        strcpy(a,b);</div><div class="line">        strcpy(b,tmp);</div><div class="line">    &#125;</div><div class="line">    int d=0,up=m+1,mid;</div><div class="line">    while(up&gt;d+1) &#123;</div><div class="line">        mid=(d+up)/2;</div><div class="line">        if(C(mid))d=mid;</div><div class="line">        else up=mid;</div><div class="line">    &#125;</div><div class="line">    return d;</div><div class="line">&#125;</div></pre></td></tr></table></k)也一定可行，尝试增加k，反之尝试缩小k，至多只会尝试o(logl)次。></p>
<h1 id="三.-n个字符串的lcs">三. N个字符串的LCS</h1>
<p>将问题扩展至N个字符串的最长公共子串后，DP算法时间复杂度会陡然变高。而hash算法的时间复杂度变为O(NLlogL)，仅是随着N线性增加，不过hash算法可能会损失一定的正确性。下面再介绍几种可以处理N个字符串LCS的算法，利用扩展KMP算法，时间复杂度是O(NL^2)；后缀数组的时间复杂度是O(NLlogL)；后缀自动机的复杂度甚至可以做到O(NL)，因此对于两个串的LCS，后缀自动机是线性时间复杂度算法，非常巧妙。</p>
<h2 id="扩展kmp">3.1 扩展KMP</h2>
<p>扩展KMP，顾名思义是KMP算法的一种扩展，它可以解决这样的问题：给出串A和串B，长度分别为lenA和lenB，要求在线性时间内，对于每个A[i]（0&lt;=i&lt;lenA)，求出A[i..lenA-1]与B的最长公共前缀长度，记为ex[i]（或者说，ex[i]为满足A[i..i+z-1]==B[0..z-1]的最大的z值）。扩展KMP的时间复杂度是线性的，只是常数会比KMP更大。</p>
<p>利用扩展KMP解决LCS问题时，假设有A、B两个字符串。可以枚举B串的每一个后缀，用这个后缀与A串做扩展KMP，遍历A[i]和这个后缀的最长公共前缀，最大值就是LCS的解。B串每个后缀做扩展KMP的时间复杂度是O(L),一共L个后缀，因此算法时间复杂度是O(L^2)，这个算法可以直接应用于N个字符串的LCS，时间复杂度为O(N*L^2)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">int next[N],extand[N];</div><div class="line">void getnext(char *T) &#123; // next[i]: 以第i位置开始的子串 与 T的公共前缀</div><div class="line">    int i,length = strlen(T);</div><div class="line">    next[0] = length;</div><div class="line">    for(i = 0; i&lt;length-1 &amp;&amp; T[i]==T[i+1]; i++);</div><div class="line">    next[1] = i;</div><div class="line">    int a = 1;</div><div class="line">    for(int k = 2; k &lt; length; k++) &#123;</div><div class="line">        int p = a+next[a]-1, L = next[k-a];</div><div class="line">        if( (k-1)+L &gt;= p ) &#123;</div><div class="line">            int j = (p-k+1)&gt;0? (p-k+1) : 0;</div><div class="line">            while(k+j&lt;length &amp;&amp; T[k+j]==T[j]) j++;// 枚举(p+1，length) 与(p-k+1,length) 区间比较</div><div class="line">            next[k] = j, a = k;</div><div class="line">        &#125; else next[k] = L;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//求出S[i..lenS-1]与T的最长公共前缀长度，记为extand[i]</div><div class="line">void getextand(char *S,char *T) &#123;</div><div class="line">    memset(next,0,sizeof(next));</div><div class="line">    getnext(T);</div><div class="line">    int Slen = strlen(S), Tlen = strlen(T), a = 0;</div><div class="line">    int MinLen = Slen&gt;Tlen?Tlen:Slen;</div><div class="line">    while(a&lt;MinLen &amp;&amp; S[a]==T[a]) a++;</div><div class="line">    extand[0] = a, a = 0;</div><div class="line">    for(int k = 1; k &lt; Slen; k++) &#123;</div><div class="line">        int p = a+extand[a]-1, L = next[k-a];</div><div class="line">        if( (k-1)+L &gt;= p ) &#123;</div><div class="line">            int j = (p-k+1)&gt;0? (p-k+1) : 0;</div><div class="line">            while(k+j&lt;Slen &amp;&amp; j&lt;Tlen &amp;&amp; S[k+j]==T[j] ) j++;</div><div class="line">            extand[k] = j;</div><div class="line">            a = k;</div><div class="line">        &#125; else extand[k] = L;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">char a[3010],b[3010];</div><div class="line">void LCS(char *a, char *b) &#123;</div><div class="line">    int ans = 0;</div><div class="line">    int lena = strlen(a), lenb = strlen(b);</div><div class="line">    for(int pb=0; pb&lt;lenb; ++pb) &#123;</div><div class="line">        getextand(a,b+pb);</div><div class="line">        for(int j=0; j&lt;lena; ++j)</div><div class="line">            ans = max(ans, extand[j]);</div><div class="line">    &#125;</div><div class="line">    printf(&quot;%d\n&quot;,ans);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="后缀数组">3.2 后缀数组</h2>
<p>后缀数组是解决字符串问题的有力工具！IOI国家集训队的两篇论文非常值得一读<em>《后缀数组》(2004年许智磊)</em>和<em>《后缀数组——处理字符串的有力工具》(2009年罗穗骞)</em>。尤其是2009年的论文，里面给出了很多经典的例题。关于<a href="https://www.byvoid.com/blog/lcs-suffix-array/" target="_blank" rel="external">最长公共子串问题的后缀数组解法</a>，byvoid在他的文章中也有详细的讲解。本文再次简要复述算法，SA[i]表示排名第i的后缀的位置，Height[i]表示后缀SA[i]和SA[i-1]的最长公共前缀(Longest Common Prefix,LCP)，简记为Height[i]=LCP(SA[i],SA[i-1])。在本文2.3节已经说明LCS问题可以二分答案，因此我们只需要讨论如何用后缀数组验证是否存在长度为K的公共子串。设N个串分别为S1,S2,S3,…,SN，首先建立一个串S，把这N个串用不同的分隔符连接起来。验证时，找出出在Height数组中找出连续的一段Height[i..j]，使得i&lt;=k&lt;=j均满足Height[k]&gt;=K，并且i-1&lt;=k&lt;=j中，SA[k]分属于原有N个串S1..SN。如果能找到这样的一段，那么K就是可行解。算法时间复杂度O(N<em>L</em>logL)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//以下为二分验证函数</div><div class="line">bool check(int K)</div><div class="line">&#123;</div><div class="line">    int i,j,k;</div><div class="line">    bool ba[MAXN];</div><div class="line">    for (i=1;i&lt;=SA.N;i++)</div><div class="line">    &#123;</div><div class="line">        if (SA.Height[i]&gt;=K)</div><div class="line">        &#123;</div><div class="line">            for (j=i;SA.Height[j]&gt;=K &amp;&amp; j&lt;=SA.N;j++);</div><div class="line">            j--;</div><div class="line">            memset(ba,0,sizeof(ba));</div><div class="line">            for (k=i-1;k&lt;=j;k++)</div><div class="line">                ba[Bel[SA.SA[k]]]=true;</div><div class="line">            for (k=1;ba[k] &amp;&amp; k&lt;=N;k++);</div><div class="line">            if (k==N+1)</div><div class="line">                return true;</div><div class="line">            i=j;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="后缀自动机">3.3 后缀自动机</h2>
<p>关于后缀自动机(SAM)的教程，可以参考<a href="http://wenku.baidu.com/link?url=cZvtkdkd8D1FYn6a6BTa8glhSwdCVlSoFvNfZbGCS5yp-Jt9ZK0A9WNZkQbe0WrCV3yBzYDloATSa1S1pOZWoYtvhyiX25Fgj3HFKf7IAnm" target="_blank" rel="external">2012年noi冬令营陈立杰讲稿</a>。SAM的内容相对复杂，若要展开讨论需要较长篇幅，在此不赘述SA性质和构造方法。对于串A和B，我们先构造出串A的后缀自动机，那么然后用B串去匹配，对于B，我们一位一位地扫描，维护一个ans值，表示从B串的开始到B[i]的这个子串与A的最长公共子串。假设现在到B[i-1]的最长公共子串长度为ans，然后我们来看B[i]，如果当前节点有B[i]这个孩子，那么直接就len++即可。如果没有就找一直向前找pre，直到找到有B[i]这个孩子的节点。SAM可以在线性时间内构造，因此时间复杂度为O(N*L)。虽然SAM算法较为复杂，但是代码却非常简短。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">struct SAM &#123;</div><div class="line">    SAM *pre,*son[26];</div><div class="line">    int len,g;</div><div class="line">&#125; que[N],*root,*tail;</div><div class="line">int tot;</div><div class="line">void add(int c,int l) &#123;</div><div class="line">    SAM *p=tail,*np=&amp;que[tot++];</div><div class="line">    np-&gt;len=l;</div><div class="line">    tail=np;</div><div class="line">    while(p&amp;&amp;p-&gt;son[c]==NULL) p-&gt;son[c]=np,p=p-&gt;pre;</div><div class="line">    if(p==NULL) np-&gt;pre=root;</div><div class="line">    else &#123;</div><div class="line">        SAM *q=p-&gt;son[c];</div><div class="line">        if(p-&gt;len+1==q-&gt;len) np-&gt;pre=q;</div><div class="line">        else &#123;</div><div class="line">            SAM *nq=&amp;que[tot++];</div><div class="line">            *nq=*q;</div><div class="line">            nq-&gt;len=p-&gt;len+1;</div><div class="line">            np-&gt;pre=q-&gt;pre=nq;</div><div class="line">            while(p&amp;&amp;p-&gt;son[c]==q) p-&gt;son[c]=nq,p=p-&gt;pre;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">char a[N/2],b[N/2];</div><div class="line">int lcs(char a[],char b[]) &#123;</div><div class="line">    memset(que,0,sizeof(que));</div><div class="line">    tot=0;</div><div class="line">    root=tail=&amp;que[tot++];</div><div class="line">    for(int i=0; a[i]; i++) add(a[i]-&apos;a&apos;,i+1);</div><div class="line">    SAM *p=root;</div><div class="line">    int ans=0;</div><div class="line">    for(int i=0,l=0; b[i]; i++,ans=max(ans,l)) &#123;</div><div class="line">        int c=b[i]-&apos;a&apos;;</div><div class="line">        if(p-&gt;son[c]) p=p-&gt;son[c],l++;</div><div class="line">        else &#123;</div><div class="line">            while(p&amp;&amp;p-&gt;son[c]==NULL) p=p-&gt;pre;</div><div class="line">            if(p==NULL) p=root,l=0;</div><div class="line">            else l=p-&gt;len+1,p=p-&gt;son[c];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return ans;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="四.-总结">四. 总结</h1>
<p>本文利用几种常见的字符串工具实现了LCS问题，从暴力穷举算法逐步优化，直至线性时间复杂度的SAM算法。逐步寻找最优解是本文的初衷，同时也可以感知到高效的算法往往简洁而优美。</p>
<p>本文提及的算法复杂度总结如下： <a href="http://7tsysl.com1.z0.glb.clouddn.com/LCS%20Complexity.png" target="_blank" rel="external"><img src="http://7tsysl.com1.z0.glb.clouddn.com/LCS%20Complexity.png" alt="LCS各算法复杂度分析"></a><a href="http://7tsysl.com1.z0.glb.clouddn.com/LCS%20Complexity.png" target="_blank" rel="external">LCS各算法复杂度分析</a> <code>L</code>: 字符串的最大长度 <code>K</code>: 最长公共子串的长度 <code>N</code>: N个字符串</p>
<h2 id="线段树">线段树</h2>
<h3 id="线段树-1">线段树</h3>
<p>　　线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。 　　对于线段树中的每一个非叶子节点[a,b]，它的左儿子表示的区间为[a,(a+b)/2]，右儿子表示的区间为[(a+b)/2+1,b]。因此线段树是平衡二叉树，最后的子节点数目为N，即整个线段区间的长度。 　　使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN）。而未优化的空间复杂度为2N，因此有时需要离散化让空间压缩。 　　线段树有很多模板，而且基本上每道题都是稍稍改动或者根本不需改动就可以直接使用线段树的模板，这里提供几个相对简洁的模板：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div></pre></td><td class="code"><pre><div class="line">//单点替换、单点增减、区间求和、区间最值</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">#define lson l , m , rt &lt;&lt; 1</div><div class="line">#define rson m + 1 , r , rt &lt;&lt; 1 | 1</div><div class="line">const int maxn = 222222;</div><div class="line"></div><div class="line">int MAX[maxn&lt;&lt;2];</div><div class="line">int MIN[maxn&lt;&lt;2];</div><div class="line">int SUM[maxn&lt;&lt;2];</div><div class="line">int max(int a,int b)&#123;if(a&gt;b)return a;else return b;&#125;</div><div class="line">int min(int a,int b)&#123;if(a&lt;b)return a;else return b;&#125;</div><div class="line"></div><div class="line">void PushUP(int rt)</div><div class="line">&#123;</div><div class="line">  MAX[rt] = max(MAX[rt&lt;&lt;1] , MAX[rt&lt;&lt;1|1]);</div><div class="line">  MIN[rt] = min(MIN[rt&lt;&lt;1] , MIN[rt&lt;&lt;1|1]);</div><div class="line">  SUM[rt] = SUM[rt&lt;&lt;1] + SUM[rt&lt;&lt;1|1];</div><div class="line">&#125;</div><div class="line"></div><div class="line">void build(int l,int r,int rt) &#123;</div><div class="line">  if (l == r)</div><div class="line">    &#123;</div><div class="line">    scanf(&quot;%d&quot;,&amp;MAX[rt]);</div><div class="line">    MIN[rt] = MAX[rt];</div><div class="line">    SUM[rt] = MAX[rt];</div><div class="line">    //printf(&quot;mi = %d\n&quot;,MIN[rt]);</div><div class="line">  //    printf(&quot;ma = %d\n&quot;,MAX[rt]);</div><div class="line">    return ;</div><div class="line">  &#125;</div><div class="line">  int m = (l + r) &gt;&gt; 1;</div><div class="line">  build(lson);</div><div class="line">  build(rson);</div><div class="line">  PushUP(rt);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void update(int p,int tihuan,int l,int r,int rt)</div><div class="line">&#123;</div><div class="line">  if (l == r) &#123;</div><div class="line">    MAX[rt] = tihuan;</div><div class="line">    MIN[rt] = tihuan;</div><div class="line">    SUM[rt] = tihuan;</div><div class="line">    return ;</div><div class="line">  &#125;</div><div class="line">  int m = (l + r) &gt;&gt; 1;</div><div class="line">  if (p &lt;= m) update(p , tihuan ,lson);</div><div class="line">  else update(p , tihuan , rson);</div><div class="line">  PushUP(rt);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void update1(int p,int add,int l,int r,int rt)</div><div class="line">&#123;</div><div class="line">  if (l == r) &#123;</div><div class="line">    SUM[rt] = SUM[rt] + add;</div><div class="line">    return ;</div><div class="line">  &#125;</div><div class="line">  int m = (l + r) &gt;&gt; 1;</div><div class="line">  if (p &lt;= m) update1(p , add ,lson);</div><div class="line">  else update1(p , add , rson);</div><div class="line">  PushUP(rt);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int query(int L,int R,int l,int r,int rt)</div><div class="line">&#123;</div><div class="line">  if (L &lt;= l &amp;&amp; r &lt;= R)</div><div class="line">  &#123;</div><div class="line">    return MAX[rt];</div><div class="line">  &#125;</div><div class="line">  int m = (l + r) &gt;&gt; 1;</div><div class="line">  int ret = -1;</div><div class="line">  if (L &lt;= m) ret = max(ret , query(L , R , lson));</div><div class="line">  if (R &gt; m)  ret =  max(ret , query(L , R , rson));</div><div class="line">  return ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int query1(int L,int R,int l,int r,int rt)</div><div class="line">&#123;</div><div class="line">  if (L &lt;= l &amp;&amp; r &lt;= R)</div><div class="line">  &#123;</div><div class="line">    return MIN[rt];</div><div class="line">  &#125;</div><div class="line">  int m = (l + r) &gt;&gt; 1;</div><div class="line">  int ret = 99999;</div><div class="line">  if (L &lt;= m) ret = min(ret , query1(L , R , lson));</div><div class="line">  if (R &gt; m)  ret =  min(ret , query1(L , R , rson));</div><div class="line">  return ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int queryhe(int L,int R,int l,int r,int rt)</div><div class="line">&#123;</div><div class="line">  if (L &lt;= l &amp;&amp; r &lt;= R)</div><div class="line">  &#123;</div><div class="line">    return SUM[rt];</div><div class="line">  &#125;</div><div class="line">  int m = (l + r) &gt;&gt; 1;</div><div class="line">  int ret = 0;</div><div class="line">  if (L &lt;= m) ret += queryhe(L , R , lson);</div><div class="line">  if (R &gt; m)  ret +=  queryhe(L , R , rson);</div><div class="line">  return ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">  int n , m;</div><div class="line">  while (~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))</div><div class="line">  &#123;</div><div class="line">    build(1 , n , 1);</div><div class="line">    while (m --) &#123;</div><div class="line">      char op[2];</div><div class="line">      int a , b;</div><div class="line">      scanf(&quot;%s%d%d&quot;,op,&amp;a,&amp;b);</div><div class="line">      if (op[0] == &apos;Q&apos;) //区间求最大</div><div class="line">      &#123;</div><div class="line">         /* for(int i = 1;i&lt;=10;i++)</div><div class="line">          printf(&quot;%d &quot;,MAX[i]);</div><div class="line">        puts(&quot;&quot;);*/</div><div class="line">        printf(&quot;%d\n&quot;,query(a , b , 1 , n , 1));</div><div class="line">      &#125;</div><div class="line">      else if(op[0]==&apos;U&apos;) //单点替换</div><div class="line">        update(a , b , 1 , n , 1);</div><div class="line">      else if(op[0]==&apos;M&apos;)//区间求最小</div><div class="line">      &#123;</div><div class="line">        /*for(int i = 1;i&lt;=10;i++)</div><div class="line">          printf(&quot;%d &quot;,MIN[i]);</div><div class="line">        puts(&quot;&quot;);*/</div><div class="line">        printf(&quot;%d\n&quot;,query1(a , b , 1 , n , 1));</div><div class="line">      &#125;</div><div class="line">      else if(op[0]==&apos;H&apos;)//区间求和</div><div class="line">      &#123;</div><div class="line">        printf(&quot;%d\n&quot;,queryhe(a , b , 1 , n , 1));</div><div class="line">      &#125;</div><div class="line">      else if(op[0]==&apos;S&apos;)//单点增加</div><div class="line">      &#123;</div><div class="line">        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</div><div class="line">        update1(a , b , 1 , n , 1);</div><div class="line">      &#125;</div><div class="line">       else if(op[0]==&apos;E&apos;)//单点减少</div><div class="line">      &#123;</div><div class="line">        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</div><div class="line">        update1(a , -b , 1 , n , 1);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line">//区间替换</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;cstdlib&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line"></div><div class="line">#define max(a,b) (a&gt;b)?a:b</div><div class="line">#define min(a,b) (a&gt;b)?b:a</div><div class="line">#define lson l , m , rt &lt;&lt; 1</div><div class="line">#define rson m + 1 , r , rt &lt;&lt; 1 | 1</div><div class="line">#define LL long long</div><div class="line">const int maxn = 100100;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int lazy[maxn&lt;&lt;2];</div><div class="line">int sum[maxn&lt;&lt;2];</div><div class="line"></div><div class="line">void PushUp(int rt)//由左孩子、右孩子向上更新父节点</div><div class="line">&#123;</div><div class="line">  sum[rt] = sum[rt&lt;&lt;1] + sum[rt&lt;&lt;1|1];</div><div class="line">&#125;</div><div class="line"></div><div class="line">void PushDown(int rt,int m) //向下更新</div><div class="line">&#123;</div><div class="line">  if (lazy[rt]) //懒惰标记</div><div class="line">  &#123;</div><div class="line">    lazy[rt&lt;&lt;1] = lazy[rt&lt;&lt;1|1] = lazy[rt];</div><div class="line">    sum[rt&lt;&lt;1] = (m - (m &gt;&gt; 1)) * lazy[rt];</div><div class="line">    sum[rt&lt;&lt;1|1] = ((m &gt;&gt; 1)) * lazy[rt];</div><div class="line">    lazy[rt] = 0;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void build(int l,int r,int rt)//建树</div><div class="line">&#123;</div><div class="line">  lazy[rt] = 0;</div><div class="line"></div><div class="line">  if (l== r)</div><div class="line">  &#123;</div><div class="line">    scanf(&quot;%d&quot;,&amp;sum[rt]);</div><div class="line">    return ;</div><div class="line">  &#125;</div><div class="line">  int m = (l + r) &gt;&gt; 1;</div><div class="line">  build(lson);</div><div class="line">  build(rson);</div><div class="line">  PushUp(rt);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void update(int L,int R,int c,int l,int r,int rt)//更新</div><div class="line">&#123;</div><div class="line">  //if(L&gt;l||R&gt;r) return;</div><div class="line">  if (L &lt;= l &amp;&amp; r &lt;= R)</div><div class="line">  &#123;</div><div class="line">    lazy[rt] = c;</div><div class="line">    sum[rt] = c * (r - l + 1);</div><div class="line">    //printf(&quot;%d %d %d %d %d\n&quot;, rt, sum[rt], c, l, r);</div><div class="line">    return ;</div><div class="line">  &#125;</div><div class="line">  PushDown(rt , r - l + 1);</div><div class="line">  int m = (l + r) &gt;&gt; 1;</div><div class="line">  if (L &lt;= m) update(L , R , c , lson);</div><div class="line">  if (R &gt; m) update(L , R , c , rson);</div><div class="line">  PushUp(rt);</div><div class="line">&#125;</div><div class="line"></div><div class="line">LL query(int L,int R,int l,int r,int rt)</div><div class="line">&#123;</div><div class="line">  if (L &lt;= l &amp;&amp; r &lt;= R)</div><div class="line">  &#123;</div><div class="line">    //printf(&quot;%d\n&quot;, sum[rt]);</div><div class="line">    return sum[rt];</div><div class="line">  &#125;</div><div class="line">  PushDown(rt , r - l + 1);</div><div class="line">  int m = (l + r) &gt;&gt; 1;</div><div class="line">  LL ret = 0;</div><div class="line">  if (L &lt;= m) ret += query(L , R , lson);</div><div class="line">  if (m &lt; R) ret += query(L , R , rson);</div><div class="line">  return ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">  int  n , m;</div><div class="line">  char str[5];</div><div class="line"></div><div class="line">  while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m))</div><div class="line">  &#123;</div><div class="line">    build(1 , n , 1);</div><div class="line">    while (m--)</div><div class="line">    &#123;</div><div class="line">      scanf(&quot;%s&quot;,str);</div><div class="line">      int a , b , c;</div><div class="line">      if(str[0]==&apos;T&apos;)</div><div class="line">      &#123;</div><div class="line">        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);</div><div class="line">        update(a , b , c , 1 , n , 1);</div><div class="line">      &#125;</div><div class="line">      else if(str[0]==&apos;Q&apos;)</div><div class="line">      &#123;</div><div class="line">        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</div><div class="line">        cout&lt;&lt;query(a,b,1,n,1)&lt;&lt;endl;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line">//区间增减</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;cstdlib&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line"></div><div class="line">#define max(a,b) (a&gt;b)?a:b</div><div class="line">#define min(a,b) (a&gt;b)?b:a</div><div class="line">#define lson l , m , rt &lt;&lt; 1</div><div class="line">#define rson m + 1 , r , rt &lt;&lt; 1 | 1</div><div class="line">#define LL __int64</div><div class="line">const int maxn = 100100;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">LL lazy[maxn&lt;&lt;2];</div><div class="line">LL sum[maxn&lt;&lt;2];</div><div class="line"></div><div class="line">void putup(int rt)</div><div class="line">&#123;</div><div class="line">  sum[rt] = sum[rt&lt;&lt;1] + sum[rt&lt;&lt;1|1];</div><div class="line">&#125;</div><div class="line"></div><div class="line">void putdown(int rt,int m)</div><div class="line">&#123;</div><div class="line">  if (lazy[rt])</div><div class="line">  &#123;</div><div class="line">    lazy[rt&lt;&lt;1] += lazy[rt];</div><div class="line">    lazy[rt&lt;&lt;1|1] += lazy[rt];</div><div class="line">    sum[rt&lt;&lt;1] += lazy[rt] * (m - (m &gt;&gt; 1));</div><div class="line">    sum[rt&lt;&lt;1|1] += lazy[rt] * (m &gt;&gt; 1);</div><div class="line">    lazy[rt] = 0;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void build(int l,int r,int rt) &#123;</div><div class="line">  lazy[rt] = 0;</div><div class="line">  if (l == r)</div><div class="line">  &#123;</div><div class="line">    scanf(&quot;%I64d&quot;,&amp;sum[rt]);</div><div class="line">    return ;</div><div class="line">  &#125;</div><div class="line">  int m = (l + r) &gt;&gt; 1;</div><div class="line">  build(lson);</div><div class="line">  build(rson);</div><div class="line">  putup(rt);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void update(int L,int R,int c,int l,int r,int rt)</div><div class="line">&#123;</div><div class="line">  if (L &lt;= l &amp;&amp; r &lt;= R)</div><div class="line">  &#123;</div><div class="line">    lazy[rt] += c;</div><div class="line">    sum[rt] += (LL)c * (r - l + 1);</div><div class="line">    return ;</div><div class="line">  &#125;</div><div class="line">  putdown(rt , r - l + 1);</div><div class="line">  int m = (l + r) &gt;&gt; 1;</div><div class="line">  if (L &lt;= m) update(L , R , c , lson);</div><div class="line">  if (m &lt; R) update(L , R , c , rson);</div><div class="line">  putup(rt);</div><div class="line">&#125;</div><div class="line"></div><div class="line">LL query(int L,int R,int l,int r,int rt)</div><div class="line">&#123;</div><div class="line">  if (L &lt;= l &amp;&amp; r &lt;= R)</div><div class="line">  &#123;</div><div class="line">    return sum[rt];</div><div class="line">  &#125;</div><div class="line">  putdown(rt , r - l + 1);</div><div class="line">  int m = (l + r) &gt;&gt; 1;</div><div class="line">  LL ret = 0;</div><div class="line">  if (L &lt;= m) ret += query(L , R , lson);</div><div class="line">  if (m &lt; R) ret += query(L , R , rson);</div><div class="line">  return ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">  int n , m;int a , b , c;</div><div class="line">  char str[5];</div><div class="line">  scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</div><div class="line">  build(1 , n , 1);</div><div class="line">  while (m--)</div><div class="line">  &#123;</div><div class="line">    scanf(&quot;%s&quot;,str);</div><div class="line">    if (str[0] == &apos;Q&apos;)</div><div class="line">    &#123;</div><div class="line">      scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</div><div class="line">      printf(&quot;%I64d\n&quot;,query(a , b , 1 , n , 1));</div><div class="line">    &#125;</div><div class="line">    else if(str[0]==&apos;C&apos;)</div><div class="line">    &#123;</div><div class="line">      scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);</div><div class="line">      update(a , b , c , 1 , n , 1);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　最简单的应用就是记录线段是否被覆盖，并随时查询当前被覆盖线段的总长度。那么此时可以在结点结构中加入一个变量int count；代表当前结点代表的子树中被覆盖的线段长度和。这样就要在插入（删除）当中维护这个count值，于是当前的覆盖总值就是根节点的count值了。 　　另外也可以将count换成bool cover；支持查找一个结点或线段是否被覆盖。 　　实际上，通过在结点上记录不同的数据，线段树还可以完成很多不同的任务。例如，如果每次插入操作是在一条线段上每个位置均加k，而查询操作是计算一条线段上的总和，那么在结点上需要记录的值为sum。 　　这里会遇到一个问题：为了使所有sum值都保持正确，每一次插入操作可能要更新O(N）个sum值，从而使时间复杂度退化为O(N）。 解决方案是Lazy思想：对整个结点进行的操作，先在结点上做标记，而并非真正执行，直到根据查询操作的需要分成两部分。 　　根据Lazy思想，我们可以在不代表原线段的结点上增加一个值toadd，即为对这个结点，留待以后执行的插入操作k值的总和。对整个结点插入时，只更新sum和toadd值而不向下进行，这样时间复杂度可证明为O(logN）。 　　对一个toadd值为0的结点整个进行查询时，直接返回存储在其中的sum值；而若对toadd不为0的一部分进行查询，则要更新其左右子结点的sum值，然后把toadd值传递下去，再对这个查询本身，左右子结点分别递归下去。时间复杂度也是O(nlogN）。</p>
<h4 id="例题">例题</h4>
<ul>
<li><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1754" target="_blank" rel="external">hdu 1754 I Hate It</a> 题意：给出一个学生成绩的序列，有两个操作：1.修改一个学生的成绩，2.查询学生A到学生B之间所有学生的最高分。　　 　　典型的单点更新求区间最值问题，直接用线段树模板即可。 <strong>代码如下：</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;string.h&gt;</div><div class="line">#define lson l,m,rt&lt;&lt;1</div><div class="line">#define rson m+1,r,rt&lt;&lt;1|1</div><div class="line">#define max 200010</div><div class="line"></div><div class="line">int N,M;</div><div class="line">int sum[max&lt;&lt;2];</div><div class="line"></div><div class="line">int Max(int a,int b)</div><div class="line">&#123;</div><div class="line">    return a&gt;b?a:b;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void PushUp(int rt)</div><div class="line">&#123;</div><div class="line">    sum[rt]=Max(sum[rt&lt;&lt;1],sum[rt&lt;&lt;1|1]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void build(int l,int r,int rt)</div><div class="line">&#123;</div><div class="line">    if(l==r)</div><div class="line">    &#123;</div><div class="line">        scanf(&quot;%d&quot;,&amp;sum[rt]);</div><div class="line">        return ;</div><div class="line">    &#125;</div><div class="line">    int m=(l+r)&gt;&gt;1;</div><div class="line">    build(lson);</div><div class="line">    build(rson);</div><div class="line">    PushUp(rt);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int query(int L,int R,int l,int r,int rt)</div><div class="line">&#123;</div><div class="line"></div><div class="line">    if(l&gt;=L&amp;&amp;r&lt;=R)</div><div class="line">    &#123;</div><div class="line">         return sum[rt];</div><div class="line">    &#125;</div><div class="line">    int maxn=0;</div><div class="line">    int m=(l+r)&gt;&gt;1;</div><div class="line">    if(L&lt;=m)</div><div class="line">       maxn=Max(maxn,query(L,R,lson));</div><div class="line">    if(R&gt;m)</div><div class="line">       maxn=Max(maxn,query(L,R,rson));</div><div class="line">    return maxn;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void update(int L,int num,int l,int r,int rt)</div><div class="line">&#123;</div><div class="line">    if(r==l)</div><div class="line">    &#123;</div><div class="line">      sum[rt]=num;</div><div class="line">      return ;</div><div class="line">    &#125;</div><div class="line">    int m=(l+r)&gt;&gt;1;</div><div class="line">    if(L&lt;=m)</div><div class="line">    update(L,num,lson);</div><div class="line">    else</div><div class="line">    update(L,num,rson);</div><div class="line">    PushUp(rt);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    char op[2];</div><div class="line">    int A,B;</div><div class="line">    while(scanf(&quot;%d%d&quot;,&amp;N,&amp;M)!=EOF)</div><div class="line">    &#123;</div><div class="line">        memset(sum,0,sizeof(sum));</div><div class="line">        build(1,N,1);</div><div class="line">        for(int i=0;i&lt;M;i++)</div><div class="line">        &#123;</div><div class="line">            scanf(&quot;%s%d%d&quot;,op,&amp;A,&amp;B);</div><div class="line">            if(op[0]==&apos;Q&apos;)</div><div class="line">            &#123;</div><div class="line">                printf(&quot;%d\n&quot;,query(A,B,1,N,1));</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">            &#123;</div><div class="line">                update(A,B,1,N,1);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><a href="http://poj.org/problem?id=3468" target="_blank" rel="external">poj 3468 A Simple Problem with Integers</a></li>
</ul>
<p>　　题意参见树状数组例题部分。 　　需要用到线段树的，update:成段增减，query:区间求和 　　介绍Lazy思想：lazy－tag思想，记录每一个线段树节点的变化值，当这部分线段的一致性被破坏我们就将这个变化值传递给子区间，大大增加了线段树的效率。 　　在此通俗的解释Lazy意思，比如现在需要对[a,b]区间值进行加c操作，那么就从根节点[1,n]开始调用update函数进行操作，如果刚好执行到一个子节点，它的节点标记为rt，这时tree[rt].l == a &amp;&amp; tree[rt].r == b 这时我们可以一步更新此时rt节点的sum[rt]的值，sum[rt] += c * (tree[rt].r - tree[rt].l + 1)，注意关键的时刻来了，如果此时按照常规的线段树的update操作，这时候还应该更新rt子节点的sum[]值，而Lazy思想恰恰是暂时不更新rt子节点的sum[]值，到此就return，直到下次需要用到rt子节点的值的时候才去更新，这样避免许多可能无用的操作，从而节省时间 。 　　</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">using namespace std;</div><div class="line">const int N = 100005;</div><div class="line">#define lson l,m,rt&lt;&lt;1</div><div class="line">#define rson m+1,r,rt&lt;&lt;1|1</div><div class="line"></div><div class="line">__int64 sum[N&lt;&lt;2],add[N&lt;&lt;2];</div><div class="line">struct Node</div><div class="line">&#123;</div><div class="line">    int l,r;</div><div class="line">    int mid()</div><div class="line">    &#123;</div><div class="line">        return (l+r)&gt;&gt;1;</div><div class="line">    &#125;</div><div class="line">&#125; tree[N&lt;&lt;2];</div><div class="line"></div><div class="line">void PushUp(int rt)</div><div class="line">&#123;</div><div class="line">    sum[rt] = sum[rt&lt;&lt;1] + sum[rt&lt;&lt;1|1];</div><div class="line">&#125;</div><div class="line"></div><div class="line">void PushDown(int rt,int m)</div><div class="line">&#123;</div><div class="line">    if(add[rt])</div><div class="line">    &#123;</div><div class="line">        add[rt&lt;&lt;1] += add[rt];</div><div class="line">        add[rt&lt;&lt;1|1] += add[rt];</div><div class="line">        sum[rt&lt;&lt;1] += add[rt] * (m - (m&gt;&gt;1));</div><div class="line">        sum[rt&lt;&lt;1|1] += add[rt] * (m&gt;&gt;1);</div><div class="line">        add[rt] = 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void build(int l,int r,int rt)</div><div class="line">&#123;</div><div class="line">    tree[rt].l = l;</div><div class="line">    tree[rt].r = r;</div><div class="line">    add[rt] = 0;</div><div class="line">    if(l == r)</div><div class="line">    &#123;</div><div class="line">        scanf(&quot;%I64d&quot;,&amp;sum[rt]);</div><div class="line">        return ;</div><div class="line">    &#125;</div><div class="line">    int m = tree[rt].mid();</div><div class="line">    build(lson);</div><div class="line">    build(rson);</div><div class="line">    PushUp(rt);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void update(int c,int l,int r,int rt)</div><div class="line">&#123;</div><div class="line">    if(tree[rt].l == l &amp;&amp; r == tree[rt].r)</div><div class="line">    &#123;</div><div class="line">        add[rt] += c;</div><div class="line">        sum[rt] += (__int64)c * (r-l+1);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    if(tree[rt].l == tree[rt].r) return;</div><div class="line">    PushDown(rt,tree[rt].r - tree[rt].l + 1);</div><div class="line">    int m = tree[rt].mid();</div><div class="line">    if(r &lt;= m) update(c,l,r,rt&lt;&lt;1);</div><div class="line">    else if(l &gt; m) update(c,l,r,rt&lt;&lt;1|1);</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">        update(c,l,m,rt&lt;&lt;1);</div><div class="line">        update(c,m+1,r,rt&lt;&lt;1|1);</div><div class="line">    &#125;</div><div class="line">    PushUp(rt);</div><div class="line">&#125;</div><div class="line"></div><div class="line">__int64 query(int l,int r,int rt)</div><div class="line">&#123;</div><div class="line">    if(l == tree[rt].l &amp;&amp; r == tree[rt].r)</div><div class="line">    &#123;</div><div class="line">        return sum[rt];</div><div class="line">    &#125;</div><div class="line">    PushDown(rt,tree[rt].r - tree[rt].l + 1);</div><div class="line">    int m = tree[rt].mid();</div><div class="line">    __int64 res = 0;</div><div class="line">    if(r &lt;= m) res += query(l,r,rt&lt;&lt;1);</div><div class="line">    else if(l &gt; m) res += query(l,r,rt&lt;&lt;1|1);</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">       res += query(l,m,rt&lt;&lt;1);</div><div class="line">       res += query(m+1,r,rt&lt;&lt;1|1);</div><div class="line">    &#125;</div><div class="line">    return res;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int n,m;</div><div class="line">    while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m))</div><div class="line">    &#123;</div><div class="line">        build(1,n,1);</div><div class="line">        while(m--)</div><div class="line">        &#123;</div><div class="line">            char ch[2];</div><div class="line">            scanf(&quot;%s&quot;,ch);</div><div class="line">            int a,b,c;</div><div class="line">            if(ch[0] == &apos;Q&apos;)</div><div class="line">            &#123;</div><div class="line">                scanf(&quot;%d %d&quot;, &amp;a,&amp;b);</div><div class="line">                printf(&quot;%I64d\n&quot;,query(a,b,1));</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            else</div><div class="line">            &#123;</div><div class="line">                scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c);</div><div class="line">                update(c,a,b,1);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><a href="http://poj.org/problem?id=1151" target="_blank" rel="external">poj 1151 Atlantis</a></li>
</ul>
<p>　　题意：求矩形的面积并 　　题解： 求矩形的并，由于矩形的位置可以多变，因此矩形的面积一下子不好求，这个时候，可以采用“分割”的思想，即把整块的矩形面积分割成几个小矩形的面积，然后求和就行了。 　　这里我们可以这样做，把每个矩形投影到y坐标轴上来，然后我们可以枚举矩形的 x 坐标，然后检测当前相邻x坐标上y方向的合法长度，两种相乘就是面积。然后关键就是如何用线段树来维护那个 “合法长度” 　　线段树的节点这样定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct node &#123;</div><div class="line">    int left,right,cov;</div><div class="line">    double len;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　cov 表示当前节点区间是否被覆盖，len 是当前区间的合法长度 　　然后我们通过“扫描线”的方法来进行扫描，枚举 x 的竖边，矩形的左边那条竖边就是入边，右边那条就是出边了。然后把所有这些竖边按照 x 坐标递增排序，每次进行插入操作，由于坐标不一定为整数，因此需要进行离散化处理。每次插入时如果当前区间被完全覆盖，那么就要对 cov 域进行更新。入边 +1 出边 -1，更新完毕后判断当前节点的 cov 域是否大于 0 ，如果大于 0，那么当前节点的 len 域就是节点所覆盖的区间。否则，如果是叶子节点，则 len=0。 如果内部节点，则 len=左右儿子的 len 之和。 <strong>代码如下:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div></pre></td><td class="code"><pre><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">#define L(x) ( x &lt;&lt; 1 )</div><div class="line">#define R(x) ( x &lt;&lt; 1 | 1 )</div><div class="line"></div><div class="line">double y[1000];</div><div class="line"></div><div class="line">struct Line</div><div class="line">&#123;</div><div class="line">    double x, y1, y2;</div><div class="line">    int flag;</div><div class="line">&#125; line[300];</div><div class="line"></div><div class="line">struct Node</div><div class="line">&#123;</div><div class="line">    int l, r, cover;</div><div class="line">    double lf, rf, len;</div><div class="line">&#125; node[1000];</div><div class="line"></div><div class="line">bool cmp ( Line a, Line b )</div><div class="line">&#123;</div><div class="line">    return a.x &lt; b.x;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void length ( int u )</div><div class="line">&#123;</div><div class="line">    if ( node[u].cover &gt; 0 )</div><div class="line">    &#123;</div><div class="line">        node[u].len = node[u].rf - node[u].lf;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    else if ( node[u].l + 1 == node[u].r )</div><div class="line">        node[u].len = 0; /* 叶子节点，len 为 0 */</div><div class="line">    else</div><div class="line">        node[u].len = node[L(u)].len + node[R(u)].len;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void build ( int u, int l, int r )</div><div class="line">&#123;</div><div class="line">    node[u].l = l; node[u].r = r;</div><div class="line">    node[u].lf = y[l]; node[u].rf = y[r];</div><div class="line">    node[u].len = node[u].cover = 0;</div><div class="line">    if ( l + 1 == r ) return;</div><div class="line">    int mid = ( l + r ) / 2;</div><div class="line">    build ( L(u), l, mid );</div><div class="line">    build ( R(u), mid, r );</div><div class="line">&#125;</div><div class="line"></div><div class="line">void update ( int u, Line e )</div><div class="line">&#123;</div><div class="line">    if ( e.y1 == node[u].lf &amp;&amp; e.y2 == node[u].rf )</div><div class="line">    &#123;</div><div class="line">        node[u].cover += e.flag;</div><div class="line">        length ( u );</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    if ( e.y1 &gt;= node[R(u)].lf )</div><div class="line">        update ( R(u), e );</div><div class="line">    else if ( e.y2 &lt;= node[L(u)].rf )</div><div class="line">        update ( L(u), e );</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">        Line temp = e;</div><div class="line">        temp.y2 = node[L(u)].rf;</div><div class="line">        update ( L(u), temp );</div><div class="line">        temp = e;</div><div class="line">        temp.y1 = node[R(u)].lf;</div><div class="line">        update ( R(u), temp );</div><div class="line">    &#125;</div><div class="line">    length ( u );</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    //freopen(&quot;a.txt&quot;,&quot;r&quot;,stdin);</div><div class="line">    int n, t, i, Case = 0;</div><div class="line">    double  x1, y1, x2, y2, ans;</div><div class="line">    while ( scanf(&quot;%d&quot;,&amp;n) &amp;&amp; n )</div><div class="line">    &#123;</div><div class="line">        for ( i = t = 1; i &lt;= n; i++, t++ )</div><div class="line">        &#123;</div><div class="line">            scanf(&quot;%lf%lf%lf%lf&quot;,&amp;x1, &amp;y1, &amp;x2, &amp;y2 );</div><div class="line">            line[t].x = x1;</div><div class="line">            line[t].y1 = y1;</div><div class="line">            line[t].y2 = y2;</div><div class="line">            line[t].flag = 1;</div><div class="line">            y[t] = y1;</div><div class="line">            t++;</div><div class="line">            line[t].x = x2;</div><div class="line">            line[t].y1 = y1;</div><div class="line">            line[t].y2 = y2;</div><div class="line">            line[t].flag = -1;</div><div class="line">            y[t] = y2;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        sort ( line + 1, line + t, cmp );</div><div class="line">        sort ( y + 1, y + t );</div><div class="line">        build ( 1, 1, t-1 );</div><div class="line">        update ( 1, line[1] );</div><div class="line"></div><div class="line">        ans = 0;</div><div class="line">        for ( i = 2; i &lt; t; i++ )</div><div class="line">        &#123;</div><div class="line">            ans += node[1].len * ( line[i].x - line[i-1].x );</div><div class="line">            update ( 1, line[i] );</div><div class="line">        &#125;</div><div class="line">        printf ( &quot;Test case #%d\n&quot;, ++Case );</div><div class="line">        printf ( &quot;Total explored area: %.2lf\n\n&quot;, ans );</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="二维线段树">二维线段树</h3>
<p>　　与一维线段树类似，把线段树的每一个区间端点想象为一棵新的线段树。我们可以用树套树的方式实现，即每个外层线段树的节点对应于一颗内层线段树。如果外层线段树根对应的区间是x方向的[1,n],那么内层线段树根节点对应的区间是y方向的[1,m],那么整个线段是可以存在一个n行m列的二维数组中。 　　也可以用一个外层线段树节点力存一颗内层线段树的方式来实现。 　　所有性质与线段树类似，插入，删除，查找等时间复杂度为O(logn * logm) 我们用一道例题来详细解释二维线段树的用法：</p>
<ul>
<li><a href="http://poj.org/problem?id=2155" target="_blank" rel="external">poj 2155 Matrix</a></li>
</ul>
<p>　　题意：每次操作可以是编辑某个矩形区域，这个区域的0改为1，1改为0，每次查询只查询某一个点的值是0还是1. 　　使用二维线段树，在修改的时候只需要先找到第一维的对应区间，在在这个区间的弟二维中查找对应区间，再做修改即可。而查找的时候，由于不同的第一维区间可能会有包含关系，所以需要对每个目标所在第一维区间查找第二维区间。 　　比如线段树的区间大小是３×３，那么在查找第一维区间是［１，２］，第二维区间是［１，２］时，就需要在线段树第一维的［１，３］和［１，２］两个区间对第二维进行查找，因为修改操作的时候可能修改了第一维的［１，３］区间，同时也修改了［１，２］区间，这样的话就不能仅仅只查找某一个第一维的区间。 　　至于本题的解法，我们可以在修改时标记某一个节点，那么这个节点以下的区间就都是要修改的，当我们在查找的时候，只需要统计查找到这个点时，一路上有多少个被修改的区间，是偶数说明呗修改回来了，是奇数那就是被修改了。 　　</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#define xlson kx&lt;&lt;1, xl, mid</div><div class="line">#define xrson kx&lt;&lt;1|1, mid+1, xr</div><div class="line">#define ylson ky&lt;&lt;1, yl, mid</div><div class="line">#define yrson ky&lt;&lt;1|1, mid+1, yr</div><div class="line">#define MAXN 1005</div><div class="line">#define mem(a) memset(a, 0, sizeof(a))</div><div class="line"></div><div class="line">bool tree[MAXN&lt;&lt;2][MAXN&lt;&lt;2];</div><div class="line">int  X, N, T;</div><div class="line">int num, X1, X2, Y1, Y2;</div><div class="line">char ch;</div><div class="line"></div><div class="line">void editY(int kx,int ky,int yl,int yr)</div><div class="line">&#123;</div><div class="line">    if(Y1&lt;=yl &amp;&amp; yr&lt;=Y2)</div><div class="line">    &#123;</div><div class="line">        tree[kx][ky] = !tree[kx][ky];</div><div class="line">        return ;</div><div class="line">    &#125;</div><div class="line">    int mid = (yl+yr)&gt;&gt;1;</div><div class="line">    if(Y1 &lt;= mid) editY(kx,ylson);</div><div class="line">    if(Y2 &gt;  mid) editY(kx,yrson);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void editX(int kx,int xl,int xr)</div><div class="line">&#123;</div><div class="line">    if(X1&lt;=xl &amp;&amp; xr&lt;=X2)</div><div class="line">    &#123;</div><div class="line">        editY(kx,1,1,N);</div><div class="line">        return ;</div><div class="line">    &#125;</div><div class="line">    int mid = (xl+xr)&gt;&gt;1;</div><div class="line">    if(X1 &lt;= mid) editX(xlson);</div><div class="line">    if(X2 &gt;  mid) editX(xrson);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void queryY(int kx,int ky,int yl,int yr)</div><div class="line">&#123;</div><div class="line">    if(tree[kx][ky]) num ++;</div><div class="line">    if(yl==yr) return ;</div><div class="line">    int mid = (yl+yr)&gt;&gt;1;</div><div class="line">    if(Y1 &lt;= mid) queryY(kx,ylson);</div><div class="line">    else queryY(kx,yrson);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void queryX(int kx,int xl,int xr)</div><div class="line">&#123;</div><div class="line">    queryY(kx,1,1,N);</div><div class="line">    if(xl==xr) return ;</div><div class="line">    int mid = (xl+xr)&gt;&gt;1;</div><div class="line">    if(X1 &lt;= mid)queryX(xlson);</div><div class="line">    else  queryX(xrson);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    while(~scanf(&quot;%d&quot;, &amp;X))while(X--)</div><div class="line">    &#123;</div><div class="line">        mem(tree);</div><div class="line">        scanf(&quot;%d %d%*c&quot;, &amp;N,&amp;T);</div><div class="line">        for(int i=0;i&lt;T;i++)</div><div class="line">        &#123;</div><div class="line">            scanf(&quot;%c %d %d%*c&quot;,&amp;ch,&amp;X1,&amp;Y1);</div><div class="line">            if(ch == &apos;C&apos;)</div><div class="line">            &#123;</div><div class="line">                scanf(&quot;%d %d%*c&quot;, &amp;X2, &amp;Y2);</div><div class="line">                editX(1,1,N);</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">            &#123;</div><div class="line">                num = 0;</div><div class="line">                queryX(1,1,N);</div><div class="line">                if(num &amp; 1)printf(&quot;1\n&quot;);</div><div class="line">                else printf(&quot;0\n&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if(X) printf(&quot;\n&quot;);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　其实使用二维数组也可以解这道题，只是把线段树部分换为树状数组。代码更为短小简洁。　　</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;string&gt;</div><div class="line">#include&lt;iostream&gt;</div><div class="line">#define N 1005</div><div class="line"></div><div class="line">int c[N][N],n;</div><div class="line"></div><div class="line">int bit(int n)</div><div class="line">&#123;  </div><div class="line">    return n&amp;(-n);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int sum(int x,int y)</div><div class="line">&#123;  </div><div class="line">    int ans=0;  </div><div class="line">    for(int i=x;i&gt;0;i-=bit(i))   </div><div class="line">        for(int j=y;j&gt;0;j-=bit(j))   </div><div class="line">        &#123;    </div><div class="line">            ans+=c[i][j];   </div><div class="line">        &#125;   </div><div class="line">        return ans;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void up(int x,int y,int k)</div><div class="line">&#123;  </div><div class="line">    for(int i=x;i&lt;=n;i+=bit(i))   </div><div class="line">        for(int j=y;j&lt;=n;j+=bit(j))   </div><div class="line">        &#123;    </div><div class="line">            c[i][j]+=k;   </div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;  </div><div class="line">    int cc,t,x1,x2,y1,y2,a,b;  </div><div class="line">    char ch;  </div><div class="line">    scanf(&quot;%d&quot;,&amp;cc);  </div><div class="line">    for(int i=0;i&lt;cc;i++)  </div><div class="line">    &#123;   </div><div class="line">        memset(c,0,sizeof(c));   </div><div class="line">        scanf(&quot;%d%d&quot;,&amp;n,&amp;t);   </div><div class="line">        getchar();   </div><div class="line">        for(int j=0;j&lt;t;j++)   </div><div class="line">        &#123;    </div><div class="line">            scanf(&quot;%c&quot;,&amp;ch);    </div><div class="line">            if(ch==&apos;C&apos;)    </div><div class="line">            &#123;     </div><div class="line">                scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);     </div><div class="line">                getchar();     </div><div class="line">                up(x1,y1,1);     </div><div class="line">                up(x1,y2+1,1);     </div><div class="line">                up(x2+1,y1,1);     </div><div class="line">                up(x2+1,y2+1,1);         </div><div class="line">            &#125;    </div><div class="line">            else    </div><div class="line">            &#123;     </div><div class="line">                scanf(&quot;%d%d&quot;,&amp;a,&amp;b);     </div><div class="line">                getchar();     </div><div class="line">                printf(&quot;%d\n&quot;,sum(a,b)%2);    </div><div class="line">            &#125;   </div><div class="line">        &#125;   </div><div class="line">        printf(&quot;\n&quot;);  </div><div class="line">    &#125;  </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="标准库">标准库</h1>
<p><strong>容器比较</strong></p>
<table style="width:100%;">
<colgroup>
<col width="6%">
<col width="13%">
<col width="17%">
<col width="16%">
<col width="11%">
<col width="11%">
<col width="11%">
<col width="11%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>vector</th>
<th>deque</th>
<th>list</th>
<th>set</th>
<th>multiset</th>
<th>map</th>
<th>multimap</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>名称</td>
<td>向量容器</td>
<td>双向队列容器</td>
<td>列表容器</td>
<td>集合</td>
<td>多重集合</td>
<td>映射</td>
<td>多重映射</td>
</tr>
<tr class="even">
<td>内部数据结构</td>
<td>连续存储的数组形式（一端开口的组）</td>
<td>连续或分段连续存储数组（两端开口的数组）</td>
<td>双向环状链表</td>
<td>红黑树（平衡检索二叉树）</td>
<td>红黑树</td>
<td>红黑树</td>
<td>红黑树</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>头文件</td>
<td>#include <vector></vector></td>
<td>#include <deque></deque></td>
<td>#include <list></list></td>
<td>#include <set></set></td>
<td>#include <set></set></td>
<td>#include <map></map></td>
<td>#include <map></map></td>
</tr>
<tr class="odd">
<td>操作元素的方式</td>
<td>下标运算符：[0]（可以用迭代器，但插入删除操作时会失效）</td>
<td>下标运算符或迭代器</td>
<td>只能用迭代器(不断用变量值来递推新值，相当于指针)，不支持使用下标运算符</td>
<td>迭代器</td>
<td>迭代器</td>
<td>迭代器</td>
<td>迭代器</td>
</tr>
<tr class="even">
<td>插入删除操作迭代器是否失效</td>
<td>插入和删除元素都会使迭代器失效</td>
<td>插入任何元素都会使迭代器失效。删除头和尾元素，指向被删除节点迭代器失效，而删除中间元素会使所有迭代器失效</td>
<td>插入，迭代器不会失效。删除，指向被删除节点迭代器失效</td>
<td>插入，迭代器不会失效。删除，指向被删除节点迭代器失效</td>
<td>插入，迭代器不会失效。删除，指向被删除节点迭代器失效</td>
<td>插入，迭代器不会失效。删除，指向被删除节点迭代器失效</td>
<td>插入，迭代器不会失效。删除，指向被删除节点迭代器失</td>
</tr>
</tbody>
</table>
<p><strong>各容器特点比较以及选择</strong></p>
<table>
<colgroup>
<col width="2%">
<col width="11%">
<col width="11%">
<col width="10%">
<col width="19%">
<col width="12%">
<col width="19%">
<col width="13%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>vector</th>
<th>deque</th>
<th>list</th>
<th>set</th>
<th>multiset</th>
<th>map</th>
<th>multimap</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>名称</td>
<td>向量容器</td>
<td>双向队列容器</td>
<td>列表容器</td>
<td>集合</td>
<td>多重集合</td>
<td>映射</td>
<td>多重映射</td>
</tr>
<tr class="even">
<td>特点</td>
<td>增加和获取元素效率很高，插入和删除的效率很低</td>
<td>增加和获取元素效率较高，插入和删除的效率较高</td>
<td>增加和获取元素效率很低，插入和删除的效率很高</td>
<td>1.键（关键字）和值（数据）相等（就是模版只有一个参数，键和值合起来）2.键唯一3.元素默认按升序排列</td>
<td>1.键和值相等2.键可以不唯一3.元素默认按升序排列</td>
<td>1.键和值分开（模版有两个参数，前面是键后面是值）2.键唯一3.元素默认按键的升序排列</td>
<td>1.键和值分开2.键可以不唯一3.元素默认按键的升序排列</td>
</tr>
<tr class="odd">
<td>定义容器</td>
<td>vector<string> book(50);</string></td>
<td>deque<string> book(50);</string></td>
<td>list<string> book;</string></td>
<td>set<string> book;</string></td>
<td>multiset<string> book;</string></td>
<td>map<int,string> book;</int,string></td>
<td>multimap<int,string> book;</int,string></td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="常用的stl查找算法">常用的STL查找算法</h1>
<p>《effective STL》中有句忠告，尽量用算法替代手写循环；查找少不了循环遍历，在这里总结下常用的STL查找算法；</p>
<p>查找有三种，即点线面： 点就是查找目标为单个元素；<br>
线就是查找目标为区间；<br>
面就是查找目标为集合；</p>
<p>针对每个类别的查找，默认的比较函数是相等，为了满足更丰富的需求，算法也都提供了自定义比较函数的版本；</p>
<h2 id="单个元素查找">单个元素查找</h2>
<h3 id="find-比较条件为相等的查找">find() 比较条件为相等的查找</h3>
<p>find()从给定区间中查找单个元素,定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">template &lt;class InputIterator, class T&gt;</div><div class="line">InputIterator find (InputIterator first, InputIterator last, const T&amp; val);</div></pre></td></tr></table></figure>
<p>示例，从myvector中查找30：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int myints[] = &#123; 10, 20, 30, 40 &#125;;</div><div class="line">std::vector&lt;int&gt; myvector (myints,myints+4);</div><div class="line">it = find (myvector.begin(), myvector.end(), 30);</div><div class="line">if (it != myvector.end())</div><div class="line">    std::cout &lt;&lt; &quot;Element found in myvector: &quot; &lt;&lt; *it &lt;&lt; &apos;\n&apos;;</div><div class="line">else</div><div class="line">    std::cout &lt;&lt; &quot;Element not found in myvector\n&quot;;</div></pre></td></tr></table></figure>
<h3 id="find_if-自定义比较函数">find_if() 自定义比较函数</h3>
<p>std::find_if():从给定区间中找出满足比较函数的第一个元素； 示例,从myvector中查找能够被30整除的第一个元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">bool cmpFunction (int i) &#123;</div><div class="line">  return ((i%30)==0);</div><div class="line">&#125;</div><div class="line">it = std::find_if (myvector.begin(), myvector.end(), cmpFunction);</div><div class="line">std::cout &lt;&lt; &quot;first:&quot; &lt;&lt;  *it &lt;&lt;std::endl;</div></pre></td></tr></table></figure>
<h3 id="count-统计元素出现次数">count() 统计元素出现次数</h3>
<p>std::count()：统计区间中某个元素出现的次数； std:count_if()：count()的自定义比较函数版本</p>
<h3 id="search_n-查询单个元素重复出现的位置">search_n() 查询单个元素重复出现的位置</h3>
<p>search_n(): find用来查询单个元素，search_n则用来查找区间中重复出现n次的元素；</p>
<p>示例：查询myvector中30连续出现2次的位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int myints[]=&#123;10,20,30,30,20,10,10,20&#125;;</div><div class="line">std::vector&lt;int&gt; myvector (myints,myints+8);</div><div class="line">it = std::search_n (myvector.begin(), myvector.end(), 2, 30);</div></pre></td></tr></table></figure>
<p>search_n() 支持自定义比较函数；</p>
<h3 id="adjacent_find-查询区间中重复元素出现的位置">adjacent_find() 查询区间中重复元素出现的位置</h3>
<p>adjacent_find() 查询区间中重复元素出现的位置，该算法支持自定义比较函数；</p>
<h3 id="lower_bound-有序区间中查询元素边界">lower_bound() 有序区间中查询元素边界</h3>
<p>lower_bound()用来在一个排序的区间中查找第一个不小于给定元素的值： 示例：查找容器v中不小于20的下界：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int myints[] = &#123;10,20,30,30,20,10,10,20&#125;;</div><div class="line">std::vector&lt;int&gt; v(myints,myints+8);           // 10 20 30 30 20 10 10 20</div><div class="line">std::sort (v.begin(), v.end());                // 10 10 10 20 20 20 30 30</div><div class="line">std::vector&lt;int&gt;::iterator low,up;</div><div class="line">low=std::lower_bound (v.begin(), v.end(), 20);</div><div class="line">std::cout &lt;&lt; &quot;lower_bound at position &quot; &lt;&lt; (low- v.begin()) &lt;&lt; &apos;\n&apos;;</div></pre></td></tr></table></figure>
<p>类似算法有upper_bound(),查找有序区间中第一个大于给定元素的值； 还有equal_range(),查找有序区间的上下边界；（一次返回lower_bound()和upper_bound());</p>
<h3 id="binary_search-有序区间的二分查找">binary_search() 有序区间的二分查找</h3>
<p>binary_search() 用来在一个有序区间中使用二分法查找元素是否在这个区间中，注，这个算法的返回值为bool， 不是下标位置，其内部的算法逻辑和lower_bound（）相似，行为表现为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">template &lt;class ForwardIterator, class T&gt;</div><div class="line">  bool binary_search (ForwardIterator first, ForwardIterator last, const T&amp; val)</div><div class="line">&#123;</div><div class="line">  first = std::lower_bound(first,last,val);</div><div class="line">  return (first!=last &amp;&amp; !(val&lt;*first));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>示例：从有序区间v中找3是否存在：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int myints[] = &#123;1,2,3,4,5,4,3,2,1&#125;;</div><div class="line">std::vector&lt;int&gt; v(myints,myints+9);                         // 1 2 3 4 5 4 3 2 1</div><div class="line">std::sort (v.begin(), v.end());</div><div class="line">if (std::binary_search (v.begin(), v.end(), 3))</div><div class="line">    std::cout &lt;&lt; &quot;found!\n&quot;; else std::cout &lt;&lt; &quot;not found.\n&quot;;</div></pre></td></tr></table></figure>
<h3 id="min_element-查找最小元素">min_element() 查找最小元素</h3>
<p>min_element() 在给定区间中查找出最小值;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int myints[] = &#123;3,7,2,5,6,4,9&#125;;</div><div class="line">std::cout &lt;&lt; &quot;The smallest element is &quot; &lt;&lt; *std::min_element(myints,myints+7) &lt;&lt; &apos;\n&apos;;</div></pre></td></tr></table></figure>
<p>类似算法有：max_element() 查找最大值；</p>
<h2 id="区间查找-search">区间查找 search()</h2>
<h3 id="search-查找子区间首次出现的位置">search() 查找子区间首次出现的位置</h3>
<p>find()用来查找单个元素，search()则用来查找一个子区间； 示例：从myvector中查找出现子区间[20，30]的位置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int needle1[] = &#123;20,30&#125;;</div><div class="line">it = std::search (myvector.begin(), myvector.end(), needle1, needle1+2);</div><div class="line">if (it!=myvector.end())</div><div class="line">  std::cout &lt;&lt; &quot;needle1 found at position &quot; &lt;&lt; (it-myvector.begin()) &lt;&lt; &apos;\n&apos;;</div></pre></td></tr></table></figure>
<p>search支持自定义比较函数； 示例：查询给定区间中每个元素比目标区间小1的子区间；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">bool cmpFunction (int i, int j) &#123;</div><div class="line">  return (i-j==1);</div><div class="line">&#125;</div><div class="line">int myints[] = &#123;1,2,3,4,5,1,2,3,4,5&#125;;</div><div class="line">std::vector&lt;int&gt; haystack (myints,myints+10);</div><div class="line"></div><div class="line">int needle2[] = &#123;1,2,3&#125;;</div><div class="line">// using predicate comparison:</div><div class="line">it = std::search (haystack.begin(), haystack.end(), needle2, needle2+3, cmpFunction);</div></pre></td></tr></table></figure>
<h3 id="find_end-查找子区间最后一次出现的位置">find_end() 查找子区间最后一次出现的位置</h3>
<p>search() 用来查找子区间第一次出现的位置，而find_end()用来查找子区间最后一次出现的位置： find_end()支持自定义比较函数；</p>
<h3 id="equal-判断两个区间是否相等">equal() 判断两个区间是否相等</h3>
<p>equal（）用来判断两个区间是否相等，该算法支持自定义比较函数；</p>
<h3 id="mismatch-查询两个区间首次出现不同的位置">mismatch() 查询两个区间首次出现不同的位置；</h3>
<p>mismatch() 查询两个区间首先出现不同的位置，这个算法也支持自定义比较函数；</p>
<h2 id="集合查找">集合查找</h2>
<h3 id="find_first_of-查找集合中的任意一个元素">find_first_of 查找集合中的任意一个元素</h3>
<p>find_first_of()用来查找给定集合中的任意一个元素: 示例：从haystack中查找A,B,C出现的位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int mychars[] = &#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;&#125;;</div><div class="line">std::vector&lt;char&gt; haystack (mychars,mychars+6);</div><div class="line">int needle[] = &#123;&apos;C&apos;,&apos;B&apos;,&apos;A&apos;&#125;;</div><div class="line">// using default comparison:</div><div class="line">it = find_first_of (haystack.begin(), haystack.end(), needle, needle+3);</div></pre></td></tr></table></figure>
<p>find_first_of支持自定义比较函数；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>,8&gt; test = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">6</span>,<span class="number">17</span>,<span class="number">19</span>&#125;;  </div><div class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>,2&gt; t2 = &#123;<span class="number">11</span>,<span class="number">13</span>&#125;;  </div><div class="line"></div><div class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>,8&gt;::iterator it;  </div><div class="line"></div><div class="line"><span class="comment">//找到t2中元素在test中第一次出现的位置，不像find函数只能找一个  </span></div><div class="line">it=search(test.begin(),test.end(),t2.begin(),t2.end());  </div><div class="line"></div><div class="line"><span class="comment">//寻找首次连续出现2次7的位置  </span></div><div class="line">it=search_n(test.begin(),test.end(),<span class="number">2</span>,<span class="number">7</span>);  </div><div class="line"></div><div class="line"><span class="comment">//寻找首次连续出现2次大于7的位置  </span></div><div class="line">it=search_n(test.begin(),test.end(),<span class="number">2</span>,<span class="number">7</span>,[](<span class="keyword">int</span> i,<span class="keyword">int</span> j)&#123;<span class="keyword">return</span> i&gt;j;&#125;);  </div><div class="line"></div><div class="line"><span class="keyword">if</span>(it!=test.end())<span class="built_in">cout</span>&lt;&lt;it-test.begin();</div></pre></td></tr></table></figure>
<h2 id="vector">vector</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; orderVector;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> m = <span class="number">0</span>;</div><div class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</div><div class="line">    orderVector.push_back(i);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itor;  <span class="comment">//定义迭代器  </span></div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; p &gt;&gt; q;</div><div class="line">    <span class="comment">//从list第一个iterator开始  </span></div><div class="line"></div><div class="line">    itor = find(orderVector.begin(), orderVector.end(), p);</div><div class="line"></div><div class="line">    orderVector.erase(itor);</div><div class="line"></div><div class="line">    itor += q;</div><div class="line"></div><div class="line">    orderVector.insert(itor, p);</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; orderVector.size(); ++i) &#123;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt; orderVector.at(i) &lt;&lt; <span class="string">" "</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>1. 头文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#include&lt;vector&gt;</div></pre></td></tr></table></figure>
<p><strong>2. vector声明及初始化</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">vector&lt;int&gt; vec;        //声明一个int型向量</div><div class="line">vector&lt;int&gt; vec(5);     //声明一个初始大小为5的int向量</div><div class="line">vector&lt;int&gt; vec(10, 1); //声明一个初始大小为10且值都是1的向量</div><div class="line">vector&lt;int&gt; vec(tmp);   //声明并用tmp向量初始化vec向量</div><div class="line">vector&lt;int&gt; tmp(vec.begin(), vec.begin() + 3);  //用向量vec的第0个到第2个值初始化tmp</div><div class="line">int arr[5] = &#123;1, 2, 3, 4, 5&#125;;   </div><div class="line">vector&lt;int&gt; vec(arr, arr + 5);      //将arr数组的元素用于初始化vec向量</div><div class="line">//说明：当然不包括arr[4]元素，末尾指针都是指结束元素的下一个元素，</div><div class="line">//这个主要是为了和vec.end()指针统一。</div><div class="line">vector&lt;int&gt; vec(&amp;arr[1], &amp;arr[4]); //将arr[1]~arr[4]范围内的元素作为vec的初始值</div></pre></td></tr></table></figure>
<p><strong>3. vector基本操作</strong></p>
<p>(1). 容量</p>
<ul>
<li>向量大小： vec.size();</li>
<li>向量最大容量： vec.max_size();</li>
<li>更改向量大小： vec.resize();</li>
<li>向量真实大小： vec.capacity();</li>
<li>向量判空： vec.empty();</li>
<li>减少向量大小到满足元素所占存储空间的大小： vec.shrink_to_fit(); //<a href="http://www.cplusplus.com/reference/vector/vector/shrink_to_fit/" target="_blank" rel="external">shrink_to_fit</a></li>
</ul>
<p>(2). 修改</p>
<ul>
<li>多个元素赋值： vec.assign(); //类似于初始化时用数组进行赋值</li>
<li>末尾添加元素： vec.push_back();</li>
<li>末尾删除元素： vec.pop_back();</li>
<li>任意位置插入元素： vec.insert();</li>
<li>任意位置删除元素： vec.erase();</li>
<li>交换两个向量的元素： vec.swap();</li>
<li>清空向量元素： vec.clear();</li>
</ul>
<p>(3)迭代器</p>
<ul>
<li>开始指针：vec.begin();</li>
<li>末尾指针：vec.end(); //指向最后一个元素的下一个位置</li>
<li>指向常量的开始指针： vec.cbegin(); //意思就是不能通过这个指针来修改所指的内容，但还是可以通过其他方式修改的，而且指针也是可以移动的。</li>
<li>指向常量的末尾指针： vec.cend();</li>
</ul>
<p>(4)元素的访问</p>
<ul>
<li>下标访问： vec[1]; //并不会检查是否越界</li>
<li>at方法访问： vec.at(1); //以上两者的区别就是at会检查是否越界，是则抛出out of range异常</li>
<li>访问第一个元素： vec.front();</li>
<li>访问最后一个元素： vec.back();</li>
<li>返回一个指针： int* p = vec.data(); //可行的原因在于vector在内存中就是一个连续存储的数组，所以可以返回一个指针指向这个数组。这是是C++11的特性。</li>
</ul>
<p>(4)算法</p>
<ul>
<li>遍历元素</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">vector&lt;int&gt;::iterator it;</div><div class="line">for (it = vec.begin(); it != vec.end(); it++)</div><div class="line">    cout &lt;&lt; *it &lt;&lt; endl;</div><div class="line">//或者</div><div class="line">for (size_t i = 0; i &lt; vec.size(); i++) &#123;</div><div class="line">    cout &lt;&lt; vec.at(i) &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>元素翻转</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#include &lt;algorithm&gt;</div><div class="line">reverse(vec.begin(), vec.end());</div></pre></td></tr></table></figure>
<ul>
<li>元素排序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#include &lt;algorithm&gt;</div><div class="line">sort(vec.begin(), vec.end()); //采用的是从小到大的排序</div><div class="line">//如果想从大到小排序，可以采用上面反转函数，也可以采用下面方法:</div><div class="line">bool Comp(const int&amp; a, const int&amp; b) &#123;</div><div class="line">    return a &gt; b;</div><div class="line">&#125;</div><div class="line">sort(vec.begin(), vec.end(), Comp);</div></pre></td></tr></table></figure>
<h2 id="list">list</h2>
<blockquote>
<p>所有的插入操作都是插入到iterator指向的元素之前</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; orderList;</div><div class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> m = <span class="number">0</span>;</div><div class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</div><div class="line">    orderList.push_back(i);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator itor;  <span class="comment">//定义迭代器  </span></div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; p &gt;&gt; q;</div><div class="line">    <span class="comment">//从list第一个iterator开始  </span></div><div class="line"></div><div class="line">    itor = find(orderList.begin(), orderList.end(), p);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(itor != orderList.end()) &#123;</div><div class="line">        itor = orderList.erase(itor);</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">abs</span>(q); ++j) &#123;</div><div class="line">            <span class="keyword">if</span>(q &gt; <span class="number">0</span>) &#123;</div><div class="line">                ++ itor;</div><div class="line"></div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(q &lt; <span class="number">0</span>) &#123;</div><div class="line">                --itor;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        orderList.insert(itor, p);</div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">itor = orderList.begin();</div><div class="line"></div><div class="line"><span class="keyword">while</span>(itor != orderList.end()) &#123;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt; *(itor ++) &lt;&lt; <span class="string">" "</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>list容器是一个双向链表，可以高效地进行插入删除元素。</p>
<h2 id="构造函数">构造函数</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">list&lt;Elem&gt; c;//空list</div><div class="line">list&lt;int&gt; c(3);//创建一个含有三个默认值是0的元素的链表</div><div class="line">list&lt;int&gt; c(5,2);//创建一个含有五个元素的链表，值都是2123</div></pre></td></tr></table></figure>
<h2 id="成员函数">成员函数</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">c.begin();//返回指向链表第一个元素的迭代器</div><div class="line">c.end();//返回指向链表最后一个元素之后的迭代器</div><div class="line">c.rbegin();</div><div class="line">c.rend();//反向迭代器</div><div class="line">c.front();//返回链表c的第一个元素</div><div class="line">c.back();//返回链表c的最后一个元素</div><div class="line">c.empty();//判断链表是否为空</div><div class="line">c.size();//返回链表c中实际元素的个数</div><div class="line">c.clear();//清空链表123456789</div></pre></td></tr></table></figure>
<h2 id="插入和删除">插入和删除</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">c.insert(pos,num);//在pos位置插入元素num</div><div class="line">c.insert(pos,n,num);//在pos位置插入n个元素num</div><div class="line">c.erase(pow);//删除pos位置的元素</div><div class="line"></div><div class="line">c.push_back(num);//在末尾增加一个元素</div><div class="line">c.pop_back();//删除末尾的元素</div><div class="line">c.push_front(num);//在开始位置增加一个元素</div><div class="line">c.pop_front();//删除第一个元素12345678</div></pre></td></tr></table></figure>
<h2 id="其他">其他</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">c.reverse();//翻转链表</div><div class="line">c.sort();//将链表排序，默认升序</div><div class="line">c.sort(cmp);//自定义小于函数123</div></pre></td></tr></table></figure>
<h1 id="demo">Demo</h1>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;list&gt;</div><div class="line">using namespace std;</div><div class="line">list&lt;int&gt; l;</div><div class="line">void printl()</div><div class="line">&#123;</div><div class="line">    list&lt;int&gt;::iterator it;</div><div class="line">    for(it = l.begin() ; it != l.end() ; it ++) &#123;</div><div class="line">        cout &lt;&lt; *it &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; &quot;&quot; &lt;&lt; endl;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    l.push_front(1);//1</div><div class="line">    l.push_back(2);//1-&gt;2</div><div class="line">    printl();//1-&gt;2</div><div class="line">    list&lt;int&gt;::iterator it = l.begin();</div><div class="line">    it ++;</div><div class="line">    l.insert(it,4);</div><div class="line">    printl();//1-&gt;4-&gt;2</div><div class="line">    l.reverse();</div><div class="line">    printl();//2-&gt;4-&gt;1</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一、vector</p>
<p>vector基于模板实现，需包含头文件vector。</p>
<p>1.定义和初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">//1.定义和初始化</div><div class="line">    vector&lt;int&gt; vec1;    //默认初始化，vec1为空</div><div class="line">    vector&lt;int&gt; vec2(vec1);  //使用vec1初始化vec2</div><div class="line">    vector&lt;int&gt; vec3(vec1.begin(),vec1.end());//使用vec1初始化vec2</div><div class="line">    vector&lt;int&gt; vec4(10);    //10个值为的元素</div><div class="line">    vector&lt;int&gt; vec5(10,4);  //10个值为的元素</div><div class="line"></div><div class="line">    //2.常用操作方法</div><div class="line">    vec1.push_back(100);            //添加元素</div><div class="line">    int size = vec1.size();         //元素个数</div><div class="line">    bool isEmpty = vec1.empty();    //判断是否为空</div><div class="line">    cout&lt;&lt;vec1[0]&lt;&lt;endl;        //取得第一个元素</div><div class="line">    vec1.insert(vec1.end(),5,3);    //从vec1.back位置插入个值为的元素</div><div class="line">    //vec1.pop_back();              //删除末尾元素</div><div class="line">    //vec1.erase(vec1.begin(),vec1.end());//删除之间的元素，其他元素前移</div><div class="line">    cout&lt;&lt;(vec1==vec2)?true:false;  //判断是否相等==、！=、&gt;=、&lt;=...</div><div class="line">    vector&lt;int&gt;::iterator iter = vec1.begin();    //获取迭代器首地址</div><div class="line">    vector&lt;int&gt;::const_iterator c_iter = vec1.begin();   //获取const类型迭代器</div><div class="line">    //vec1.clear();                 //清空元素</div><div class="line"></div><div class="line">    //3.遍历</div><div class="line">    //下标法</div><div class="line">    int length = vec1.size();</div><div class="line">    for(int i=0;i&lt;length;i++)</div><div class="line">    &#123;</div><div class="line">       cout&lt;&lt;vec1[i];</div><div class="line">    &#125;</div><div class="line">    cout&lt;&lt;endl&lt;&lt;endl;</div><div class="line">    //迭代器法</div><div class="line">    vector&lt;int&gt;::const_iterator iterator = vec1.begin();</div><div class="line">    for(;iterator != vec1.end();iterator++)</div><div class="line">    &#123;</div><div class="line">       cout&lt;&lt;*iterator;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>二、list</p>
<p>List是stl实现的双向链表，与 向量(vectors)相比, 它允许快速的插入和删除，但是随机访问却比较慢。需要添加头文件list</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">//1.定义和初始化</div><div class="line">    list&lt;int&gt; lst1;          //创建空list</div><div class="line">    list&lt;int&gt; lst2(3);       //创建含有三个元素的list</div><div class="line">    list&lt;int&gt; lst3(3,2); //创建含有三个元素的list</div><div class="line">    list&lt;int&gt; lst4(lst2);    //使用lst2初始化lst4</div><div class="line">    list&lt;int&gt; lst5(lst2.begin(),lst2.end());  //同lst4</div><div class="line"></div><div class="line">    //2.常用操作方法</div><div class="line">    lst1.assign(lst2.begin(),lst2.end());  //分配值</div><div class="line">    lst1.push_back(10);                    //添加值</div><div class="line">    lst1.pop_back();                   //删除末尾值</div><div class="line">    lst1.begin();                      //返回首值的迭代器</div><div class="line">    lst1.end();                            //返回尾值的迭代器</div><div class="line">    lst1.clear();                      //清空值</div><div class="line">    bool isEmpty1 = lst1.empty();          //判断为空</div><div class="line">    lst1.erase(lst1.begin(),lst1.end());                        //删除元素</div><div class="line">    lst1.front();                      //返回第一个元素的引用</div><div class="line">    lst1.back();                       //返回最后一个元素的引用</div><div class="line">    lst1.insert(lst1.begin(),3,2);         //从指定位置插入个</div><div class="line">    lst1.rbegin();                         //返回第一个元素的前向指针</div><div class="line">    lst1.remove(2);                        //相同的元素全部删除</div><div class="line">    lst1.reverse();                        //反转</div><div class="line">    lst1.size();                       //含有元素个数</div><div class="line">    lst1.sort();                       //排序</div><div class="line">    lst1.unique();                         //删除相邻重复元素</div><div class="line"></div><div class="line">    //3.遍历</div><div class="line">    //迭代器法</div><div class="line">    for(list&lt;int&gt;::const_iterator iter = lst1.begin();iter != lst1.end();iter++)</div><div class="line">    &#123;</div><div class="line">       cout&lt;&lt;*iter;</div><div class="line">    &#125;</div><div class="line">    cout&lt;&lt;endl;</div></pre></td></tr></table></figure>
<p>三、deque</p>
<p>deque容器类与vector类似，支持随机访问和快速插入删除，它在容器中某一位置上的操作所花费的是线性时间。与vector不同的是，deque还支持从开始端插入数据：push_front()。其余类似vector操作方法的使用。</p>
<p>四、map</p>
<p>C++中map容器提供一个键值对（key/value）容器，map与multimap差别仅仅在于multiple允许一个键对应多个值。需要包含头文件map。对于迭代器来说，可以修改实值，而不能修改key。Map会根据key自动排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">//1.定义和初始化</div><div class="line">    map&lt;int,string&gt; map1;                  //空map</div><div class="line"></div><div class="line">    //2.常用操作方法</div><div class="line">    map1[3] = &quot;Saniya&quot;;                    //添加元素</div><div class="line">    map1.insert(map&lt;int,string&gt;::value_type(2,&quot;Diyabi&quot;));//插入元素</div><div class="line">    //map1.insert(pair&lt;int,string&gt;(1,&quot;Siqinsini&quot;));</div><div class="line">    map1.insert(make_pair&lt;int,string&gt;(4,&quot;V5&quot;));</div><div class="line">    string str = map1[3];                  //根据key取得value，key不能修改</div><div class="line">    map&lt;int,string&gt;::iterator iter_map = map1.begin();//取得迭代器首地址</div><div class="line">    int key = iter_map-&gt;first;             //取得eky</div><div class="line">    string value = iter_map-&gt;second;       //取得value</div><div class="line">    map1.erase(iter_map);                  //删除迭代器数据</div><div class="line">    map1.erase(3);                         //根据key删除value</div><div class="line">    map1.size();                       //元素个数</div><div class="line">    map1.empty();                       //判断空</div><div class="line">    map1.clear();                      //清空所有元素</div><div class="line"></div><div class="line">    //3.遍历</div><div class="line">    for(map&lt;int,string&gt;::iterator iter = map1.begin();iter!=map1.end();iter++)</div><div class="line">    &#123;</div><div class="line">       int keyk = iter-&gt;first;</div><div class="line">       string valuev = iter-&gt;second;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>五、set</p>
<p>set的含义是集合，它是一个有序的容器，里面的元素都是排序好的，支持插入，删除，查找等操作，就像一个集合一样。所有的操作的都是严格在logn时间之内完成，效率非常高。set和multiset的区别是：set插入的元素不能相同，但是multiset可以相同。Set默认自动排序。使用方法类似list。</p>
<p>六、各种容器总结（转自：http://hi.baidu.com/ewook/item/514fc22ecde5940e73863e65）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">(1) **vector**</div><div class="line">内部数据结构：数组。</div><div class="line">随机访问每个元素，所需要的时间为常量。</div><div class="line">在末尾增加或删除元素所需时间与元素数目无关，在中间或开头增加或删除元素所需时间随元素数目呈线性变化。</div><div class="line">可动态增加或减少元素，内存管理自动完成，但程序员可以使用reserve()成员函数来管理内存。</div><div class="line">vector的迭代器在内存重新分配时将失效（它所指向的元素在该操作的前后不再相同）。当把超过capacity()-size()个元素插入vector中时，内存会重新分配，所有的迭代器都将失效；否则，指向当前元素以后的任何元素的迭代器都将失效。当删除元素时，指向被删除元素以后的任何元素的迭代器都将失效。</div><div class="line"></div><div class="line">(2)**deque**</div><div class="line">内部数据结构：数组。</div><div class="line">随机访问每个元素，所需要的时间为常量。</div><div class="line">在开头和末尾增加元素所需时间与元素数目无关，在中间增加或删除元素所需时间随元素数目呈线性变化。</div><div class="line">可动态增加或减少元素，内存管理自动完成，不提供用于内存管理的成员函数。</div><div class="line">增加任何元素都将使deque的迭代器失效。在deque的中间删除元素将使迭代器失效。在deque的头或尾删除元素时，只有指向该元素的迭代器失效。</div><div class="line"></div><div class="line">(3)**list**</div><div class="line">内部数据结构：双向环状链表。</div><div class="line">不能随机访问一个元素。</div><div class="line">可双向遍历。</div><div class="line">在开头、末尾和中间任何地方增加或删除元素所需时间都为常量。</div><div class="line">可动态增加或减少元素，内存管理自动完成。</div><div class="line">增加任何元素都不会使迭代器失效。删除元素时，除了指向当前被删除元素的迭代器外，其它迭代器都不会失效。</div><div class="line"></div><div class="line">(4)**slist**</div><div class="line">内部数据结构：单向链表。</div><div class="line">不可双向遍历，只能从前到后地遍历。</div><div class="line">其它的特性同list相似。</div><div class="line"></div><div class="line">(5)**stack**</div><div class="line">适配器，它可以将任意类型的序列容器转换为一个堆栈，一般使用deque作为支持的序列容器。</div><div class="line">元素只能后进先出（LIFO）。</div><div class="line">不能遍历整个stack。</div><div class="line"></div><div class="line">(6)**queue**</div><div class="line">适配器，它可以将任意类型的序列容器转换为一个队列，一般使用deque作为支持的序列容器。</div><div class="line">元素只能先进先出（FIFO）。</div><div class="line">不能遍历整个queue。</div><div class="line"></div><div class="line">(7)**priority_queue**</div><div class="line">适配器，它可以将任意类型的序列容器转换为一个优先级队列，一般使用vector作为底层存储方式。</div><div class="line">只能访问第一个元素，不能遍历整个priority_queue。</div><div class="line">第一个元素始终是优先级最高的一个元素。</div><div class="line"></div><div class="line">(8)**set**</div><div class="line">键和值相等。</div><div class="line">键唯一。</div><div class="line">元素默认按升序排列。</div><div class="line">如果迭代器所指向的元素被删除，则该迭代器失效。其它任何增加、删除元素的操作都不会使迭代器失效。</div><div class="line"></div><div class="line">(9)**multiset**</div><div class="line">键可以不唯一。</div><div class="line">其它特点与set相同。</div><div class="line"></div><div class="line">(10)**hash_set**</div><div class="line">与set相比较，它里面的元素不一定是经过排序的，而是按照所用的hash函数分派的，它能提供更快的搜索速度（当然跟hash函数有关）。</div><div class="line">其它特点与set相同。</div><div class="line"></div><div class="line">(11)**hash_multiset**</div><div class="line">键可以不唯一。</div><div class="line">其它特点与hash_set相同。</div><div class="line"></div><div class="line">(12)**map**</div><div class="line">键唯一。</div><div class="line">元素默认按键的升序排列。</div><div class="line">如果迭代器所指向的元素被删除，则该迭代器失效。其它任何增加、删除元素的操作都不会使迭代器失效。</div><div class="line"></div><div class="line">(13)**multimap**</div><div class="line">键可以不唯一。</div><div class="line">其它特点与map相同。</div><div class="line"></div><div class="line">(14)**hash_map**</div><div class="line">与map相比较，它里面的元素不一定是按键值排序的，而是按照所用的hash函数分派的，它能提供更快的搜索速度（当然也跟hash函数有关）。</div><div class="line">其它特点与map相同。</div><div class="line"></div><div class="line">(15)**hash_multimap**</div><div class="line">键可以不唯一。</div><div class="line">其它特点与hash_map相同。</div></pre></td></tr></table></figure>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>打赏</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/uploads/wechat-pay.png" alt="青枫 WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/uploads/ali-pay.jpg" alt="青枫 Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong>本文作者：</strong>
      青枫
    </li>
    <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://2young.2simple.top/article/机考准备.html" title="机考准备">https://2young.2simple.top/article/机考准备.html</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明： </strong>
      本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！
    </li>
  </ul>


      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/CCF/" rel="tag"># CCF</a>
          
            <a href="/tags/算法/" rel="tag"># 算法</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/article/大规模数据处理大作业报告.html" rel="next" title="司机之友---出租车行车记录分析报告">
                <i class="fa fa-chevron-left"></i> 司机之友---出租车行车记录分析报告
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/article/计算机网络管理-课程设计选题辅导.html" rel="prev" title="计算机网络管理-课程设计选题辅导">
                计算机网络管理-课程设计选题辅导 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="青枫" />
          <p class="site-author-name" itemprop="name">青枫</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">65</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">37</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/qingfeng14" target="_blank" title="GitHub" rel="external nofollow">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.facebook.com/qingfeng.alex" target="_blank" title="Facebook" rel="external nofollow">
                  
                    <i class="fa fa-fw fa-facebook"></i>
                  
                  Facebook
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/qingfeng14" target="_blank" title="微博" rel="external nofollow">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/alex-zhangch/activities" target="_blank" title="知乎" rel="external nofollow">
                  
                    <i class="fa fa-fw fa-user-o"></i>
                  
                  知乎
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://music.163.com/#/user/home?id=95180074" target="_blank" title="网易云" rel="external nofollow">
                  
                    <i class="fa fa-fw fa-music"></i>
                  
                  网易云
                </a>
              </span>
            
          
        </div>

        
        

        
        

        
        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#二分法"><span class="nav-number">1.</span> <span class="nav-text">二分法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态规划"><span class="nav-number">2.</span> <span class="nav-text">动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最长公共子序列求解递归与动态规划方法"><span class="nav-number">3.</span> <span class="nav-text">最长公共子序列求解：递归与动态规划方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#最长公共子序列和最长公共子串区别"><span class="nav-number"></span> <span class="nav-text">最长公共子序列和最长公共子串区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#一最长公共子序列"><span class="nav-number"></span> <span class="nav-text">一、最长公共子序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#只求最长子序列长度"><span class="nav-number">1.</span> <span class="nav-text">只求最长子序列长度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#要输出一个lcs的内容"><span class="nav-number">2.</span> <span class="nav-text">要输出一个LCS的内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#要输出所有lcs的内容"><span class="nav-number">3.</span> <span class="nav-text">要输出所有LCS的内容</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二最长公共子串"><span class="nav-number"></span> <span class="nav-text">二、最长公共子串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#并查集"><span class="nav-number">1.</span> <span class="nav-text">并查集</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#经典数据结构并查集"><span class="nav-number"></span> <span class="nav-text">【经典数据结构】并查集</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#最长公共子串问题的几种算法"><span class="nav-number"></span> <span class="nav-text">最长公共子串问题的几种算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一.-最长公共子串"><span class="nav-number">1.</span> <span class="nav-text">一. 最长公共子串</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二.-两个字符串的lcs"><span class="nav-number"></span> <span class="nav-text">二. 两个字符串的LCS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#朴素穷举算法"><span class="nav-number">1.</span> <span class="nav-text">2.1 朴素穷举算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态规划算法"><span class="nav-number">2.</span> <span class="nav-text">2.2 动态规划算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串哈希"><span class="nav-number">3.</span> <span class="nav-text">2.3 字符串哈希</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三.-n个字符串的lcs"><span class="nav-number"></span> <span class="nav-text">三. N个字符串的LCS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展kmp"><span class="nav-number">1.</span> <span class="nav-text">3.1 扩展KMP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#后缀数组"><span class="nav-number">2.</span> <span class="nav-text">3.2 后缀数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#后缀自动机"><span class="nav-number">3.</span> <span class="nav-text">3.3 后缀自动机</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#四.-总结"><span class="nav-number"></span> <span class="nav-text">四. 总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#线段树"><span class="nav-number">1.</span> <span class="nav-text">线段树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线段树-1"><span class="nav-number">1.1.</span> <span class="nav-text">线段树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#例题"><span class="nav-number">1.1.1.</span> <span class="nav-text">例题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二维线段树"><span class="nav-number">1.2.</span> <span class="nav-text">二维线段树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#标准库"><span class="nav-number"></span> <span class="nav-text">标准库</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常用的stl查找算法"><span class="nav-number"></span> <span class="nav-text">常用的STL查找算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#单个元素查找"><span class="nav-number">1.</span> <span class="nav-text">单个元素查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#find-比较条件为相等的查找"><span class="nav-number">1.1.</span> <span class="nav-text">find() 比较条件为相等的查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#find_if-自定义比较函数"><span class="nav-number">1.2.</span> <span class="nav-text">find_if() 自定义比较函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#count-统计元素出现次数"><span class="nav-number">1.3.</span> <span class="nav-text">count() 统计元素出现次数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#search_n-查询单个元素重复出现的位置"><span class="nav-number">1.4.</span> <span class="nav-text">search_n() 查询单个元素重复出现的位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#adjacent_find-查询区间中重复元素出现的位置"><span class="nav-number">1.5.</span> <span class="nav-text">adjacent_find() 查询区间中重复元素出现的位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lower_bound-有序区间中查询元素边界"><span class="nav-number">1.6.</span> <span class="nav-text">lower_bound() 有序区间中查询元素边界</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binary_search-有序区间的二分查找"><span class="nav-number">1.7.</span> <span class="nav-text">binary_search() 有序区间的二分查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#min_element-查找最小元素"><span class="nav-number">1.8.</span> <span class="nav-text">min_element() 查找最小元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#区间查找-search"><span class="nav-number">2.</span> <span class="nav-text">区间查找 search()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#search-查找子区间首次出现的位置"><span class="nav-number">2.1.</span> <span class="nav-text">search() 查找子区间首次出现的位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#find_end-查找子区间最后一次出现的位置"><span class="nav-number">2.2.</span> <span class="nav-text">find_end() 查找子区间最后一次出现的位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#equal-判断两个区间是否相等"><span class="nav-number">2.3.</span> <span class="nav-text">equal() 判断两个区间是否相等</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mismatch-查询两个区间首次出现不同的位置"><span class="nav-number">2.4.</span> <span class="nav-text">mismatch() 查询两个区间首次出现不同的位置；</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合查找"><span class="nav-number">3.</span> <span class="nav-text">集合查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#find_first_of-查找集合中的任意一个元素"><span class="nav-number">3.1.</span> <span class="nav-text">find_first_of 查找集合中的任意一个元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vector"><span class="nav-number">4.</span> <span class="nav-text">vector</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#list"><span class="nav-number">5.</span> <span class="nav-text">list</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造函数"><span class="nav-number">6.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#成员函数"><span class="nav-number">7.</span> <span class="nav-text">成员函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#插入和删除"><span class="nav-number">8.</span> <span class="nav-text">插入和删除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他"><span class="nav-number">9.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#demo"><span class="nav-number"></span> <span class="nav-text">Demo</span></a></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">青枫</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io" rel="external nofollow">Hexo</a> 强力驱动
</div>


<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" rel="external nofollow">
    NexT.Pisces
  </a>
</div>

<br/>






<div class="powered-by">
Contact Me @  <a href="https://www.zhihu.com/people/alex-zhangch/activities" target="_blank" title="知乎" rel="external nofollow">知乎</a>
</div>

<div class="powered-by">
<a href="https://github.com/qingfeng14" target="_blank" title="GitHUb" rel="external nofollow">GitHub</a>
</div>

<div class="powered-by">
<a href="http://weibo.com/qingfeng14" target="_blank" title="微博" rel="external nofollow">微博</a>
</div>

<div class="theme-info">
 <a href="mailto:zhangshenghao1995@163.com?subject=用户意见" target="_blank" title="邮箱" rel="external nofollow">邮箱</a>



</div>

        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  
    
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "d5c03ba471cf40c0b5831477b3e52b64",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
  







  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("VtTcivvjyRHmU2GlrgFshvUm-gzGzoHsz", "Ls6YjvYF6PU5qtBlLt7DpMnr");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->


  


  


</body>
</html>
