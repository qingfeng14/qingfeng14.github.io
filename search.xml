<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[搜索引擎性能评价实验]]></title>
      <url>%2F2017%2F03%2F18%2F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7%E5%AE%9E%E9%AA%8C%2F</url>
      <content type="text"><![CDATA[实验步骤 自由分组， 至多2人一组 构建查询样例集合：利用网络资源(http://top.baidu.com/; http://top.sogou.com/等)和个人使用经验构建查询样例集合，查询样例集合需覆盖不同查询热门程度（ 冷门/热门） 和各种类型的用户查询需求（ 导航类/信息类/事务类），样例集合的规模为10个查询，各类比例为2:5:3， 并根据个人经验，撰写每个查询样例的信息需求内容。 构建Pooling：学生根据其构建的查询样例集合，抓取常用的三个中文搜索引擎(百度、360好搜、搜狗)对这部分查询词的查询结果，每个搜索引擎抓取查询结果的前十位结果，并利用这些结果构建Pooling。 构建相关性标注集合：根据步骤2中撰写好的信息需求，对Pooling里的结果进行标注，标注为“ 答案” 和“ 非答案” 两类即可。 根据标注结果，依据MAP，P@10，MRR等评价指标对各个搜索引擎的查询性能进行评价，并对搜索引擎满足不同信息需求的情况加以比较，每人各自撰写实验报告。 扩展内容：可以尝试对搜索引擎处理非中文查询、有错别字查询等情况的不同策略进行分析、比较。 查询样例集合创建导航类信息类萨德入韩(热门) 事务类]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CCF2016]]></title>
      <url>%2F2017%2F03%2F16%2FCCF2016%2F</url>
      <content type="text"><![CDATA[2016年CCF真题练习 Mac 下C++的编译 gcc -o target source.cpp -lstdc++ 2016-12 第一题 中间数试题名称： 中间数时间限制： 1.0s内存限制： 256.0MB 12345678910111213141516171819202122232425262728293031问题描述 在一个整数序列a1, a2, …, an中，如果存在某个数，大于它的整数数量等于小于它的整数数量，则称其为中间数。在一个序列中，可能存在多个下标不相同的中间数，这些中间数的值是相同的。 给定一个整数序列，请找出这个整数序列的中间数的值。输入格式 输入的第一行包含了一个整数n，表示整数序列中数的个数。 第二行包含n个正整数，依次表示a1, a2, …, an。输出格式 如果约定序列的中间数存在，则输出中间数的值，否则输出-1表示不存在中间数。样例输入62 6 5 6 3 5样例输出5样例说明 比5小的数有2个，比5大的数也有2个。样例输入43 4 6 7样例输出-1样例说明 在序列中的4个数都不满足中间数的定义。样例输入53 4 6 6 7样例输出-1样例说明 在序列中的5个数都不满足中间数的定义。评测用例规模与约定 对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ ai ≤ 1000。 思路：调用库函数进行排序，然后从中间向两侧进行查找 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt;using namespace std;int a[1002];int main(int argc, char const *argv[])&#123; /* code */ int n = 0; cin &gt;&gt; n; for(int i = 0; i &lt; n; ++i) &#123; cin&gt;&gt;a[i]; &#125; sort(a, a+ n); int min = n/2; int max = n/2; // 一开始这里的设置是错的 for(int i = n/2; i&lt; n; ++i) &#123; if(a[n/2] &lt; a[i]) &#123; max = i; break; &#125; &#125; for(int i = n/2; i&gt;=0; --i) &#123; if(a[n/2] &gt; a[i]) &#123; min = i; break; &#125; &#125; if(n-1-max+1 == min + 1 || (max ==n/2 &amp;&amp; min ==n/2) ) &#123; cout &lt;&lt; a[n/2]&lt;&lt;"\n"; &#125; else &#123; cout&lt;&lt; -1&lt;&lt;"\n"; &#125; return 0;&#125; 2016-12第二题 工资计算试题编号： 201612-2试题名称： 工资计算时间限制： 1.0s内存限制： 256.0MB 12345678910111213141516171819202122问题描述 小明的公司每个月给小明发工资，而小明拿到的工资为交完个人所得税之后的工资。假设他一个月的税前工资（扣除五险一金后、未扣税前的工资）为S元，则他应交的个人所得税按如下公式计算： 1） 个人所得税起征点为3500元，若S不超过3500，则不交税，3500元以上的部分才计算个人所得税，令A=S-3500元； 2） A中不超过1500元的部分，税率3%； 3） A中超过1500元未超过4500元的部分，税率10%； 4） A中超过4500元未超过9000元的部分，税率20%； 5） A中超过9000元未超过35000元的部分，税率25%； 6） A中超过35000元未超过55000元的部分，税率30%； 7） A中超过55000元未超过80000元的部分，税率35%； 8） A中超过80000元的部分，税率45%； 例如，如果小明的税前工资为10000元，则A=10000-3500=6500元，其中不超过1500元部分应缴税1500×3%=45元，超过1500元不超过4500元部分应缴税(4500-1500)×10%=300元，超过4500元部分应缴税(6500-4500)×20%=400元。总共缴税745元，税后所得为9255元。 已知小明这个月税后所得为T元，请问他的税前工资S是多少元。输入格式 输入的第一行包含一个整数T，表示小明的税后所得。所有评测数据保证小明的税前工资为一个整百的数。输出格式 输出一个整数S，表示小明的税前工资。样例输入9255样例输出10000评测用例规模与约定 对于所有评测用例，1 ≤ T ≤ 100000。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IPv6协议转发实验]]></title>
      <url>%2F2017%2F03%2F16%2FIPv6%E5%8D%8F%E8%AE%AE%E8%BD%AC%E5%8F%91%E5%AE%9E%E9%AA%8C%2F</url>
      <content type="text"><![CDATA[p{ text-indent: 2em; } 实验目的通过前面的实验，我们已经深入了解了 IPv6 协议的分组接收和发送处理流程。本实验需要将实验模块的角色定位从通信两端的主机转移到作为中间节点的路由器上，在 IPv6 分组收发处理的基础上，实现分组的路由转发功能。 网络层协议最为关注的是如何将 IPv6 分组从源主机通过网络送达目的主机，这个任务就是由路由器中的 IPv6协议模块所承担。路由器根据自身所获得的路由信息，将收到的 IPv6分组转发给正确的下一跳路由器。如此逐跳地对分组进行转发，直至该分组抵达目的主机。 IPv6 分组转发是路由器最为重要的功能。 本实验设计实现路由器中的 IPv6 协议，可以在原有 IPv6 分组收发实验的基础上，增加 IPv6 分组的转发功能。对网络的观察视角由主机转移到路由器中，了解路由器是如何为分组选择路由，并逐跳地将分组发送到目的端的。 大家在本实验中也会初步接触路由表这一重要的数据结构，认识路由器是如何根据路由表对分组进行转发的。 实验具体任务对于每一个到达本机的 IPv6 分组，根据其目的 IPv6 地址查找本机的路由表，对该分组进行如下的几类操作： 丢弃查不到路由的分组； 向上层协议上交目的地址为本机地址的分组； 根据路由查找结果，向相应接口转发其余的分组。 实验内容实验内容主要包括： 设计路由表数据结构：设计路由表所采用的数据结构。要求能够根据 IPv6 地址来确定分组处理行为（丢弃、 上交或转发），转发情况下需获得下一跳的 IPv6 地址。路由表的数据结构和查找算法会极大的影响路由器的转发性能，有兴趣的同学可以深入思考和探索。 IPv6 分组的接收和发送：对前面实验中所完成的代码进行修改，在路由器协议栈的 IPv6 模块中能够正确完成分组的接收和发送处理。具体要求不做改变，参见IPv6 分组收发实验。 IPv6 分组的转发：对于需要转发的分组进行处理，获得下一跳的 IP 地址，然后调用发送接口函数进一步处理。 实验说明：具体实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** THIS FILE IS FOR IPv6 FORWARD TEST*/// system support#include "sysinclude.h"extern void ipv6_fwd_DiscardPkt(char *pBuffer, int type);/*参数： pBuffer：指向被丢弃的报文 type：表示错误类型，包括 TTL 错误和找不到路由两种错误，定义如下： # define STUD_IPV6_FORWARD_TEST_HOPLIMIT_ERROR #define STUD_IPV6_FORWARD_TEST_NOROUTE说明： 本函数是丢弃分组的函数，在接收流程中检查到错误时调用此函数将分组丢弃*/extern void ipv6_fwd_SendtoLower(char *pBuffer, int length, ipv6_addr *nexthop);/*参数： pBuffer：指向所要发送的 IPv6 分组的起始地址，指向数据为网络字节序，是从ipv6头开始的 length：分组的整个长度（包括分组头部） nexthop：为转发处理时下一跳的地址。说明： 本函数是发送流程的下层接口函数，在 IPv6 协议模块完成发送封装工作后调用该接口函数进行后续发送处理。*/extern void getIpv6Address(ipv6_addr *pAddr);/*本函数用于获取本机的 IPv6地址，该函数即可返回本机的 IPv6地址pAddr：返回的 IPv6 地址结构的指针*/extern void ipv6_fwd_LocalRcv(char *pBuffer, int length);// 分组上交函数，在对 IPv6 的分组完成解析处理之后，如果分组的目的地址是本机的地址，则调用本函数将正确分组提交上层相应协议模块进一步处理。// 自定义路由表数据结构struct Router&#123; ipv6_addr dest; // 目的地址 UINT32 masklen; // 掩码长度 ipv6_addr nexthop;// 下一跳 struct Router *next;// 链表下一个节点 &#125;RouterTables;// 链表的head和创建的新节点的位置RouterTables *head = null;RouterTables *p = null;void stud_ipv6_Route_Init()&#123; /* 本函数用于对路由表进行初始化，在系统初始化的时候将调用该函数，对学生自己写的路由表数据结构进行初始化操作。 */ return;&#125;void stud_ipv6_route_add(stud_ipv6_route_msg *proute)&#123; /* 参数： proute：需要添加的路由，其数据结构 stud_ipv6_route_msg 的定义如下： typedef stud_route_msg &#123; ipv6_addr dest; // 地址段 UINT32 masklen; // ipv6_addr nexthop;//下一跳地址 &#125; stud_ipv6_route_msg; 说明： 本函数为路由表配置接口，系统在配置路由表时需要调用此接口。此函数功能为向路由表中增加一个新的表项，将参数所传递的路由信息添加到路由表中。 */ RouterTables * newRouter = new Router(); newRouter-&gt;dest return;&#125;int stud_ipv6_fwd_deal(char *pBuffer, int length)&#123; /* 接收函数，实现分组接收处理.根据分组中 参数： pBuffer ：指向所及受到的 IPv6 分组头部 length：为 IPv6 分组的长度 返回值： 处理该包的返回值， 0 为成功， 1 为失败； 说明： 本函数是 IPv6 协议接收流程的下层接口函数，实验系统从网络中接收 到分组后会调用本函数。调用该函数之前已完成 IPv6 报文的合法性检查 */ // a.判定是否为本机接收的分组，如果是则调用 ipv6_fwd_LocalRcv( )； // b. 按照最长匹配查找路由表获取下一跳，查找失败则调用ipv6_fwd_DiscardPkt( )； // c. 需要转发，hop limit - 1 ,调用 ipv6_fwd_SendtoLower( )完成报文发送； return 0;&#125; 本实验中需要注意的几个问题是：IPV6地址结构体的定义IPv6转发实验没有给出ipv6_addr结构体的定义，而比较地址时需要 广播地址也需要上交分组 最后一跳时需要将分组直接转发给目的主机]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux/Mac 常用命令]]></title>
      <url>%2F2017%2F03%2F15%2Flinux-Mac-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[使用pandoc将markdown输出为pdfpandoc的安装与配置 1234567891011pandoc hello-world.md -o out.pdf --latex-engine=xelatex# 如果提示pandoc无法找到插件xelatex（支持输出中文），则下载Tex，BasicTexpandoc hello-world.md -o out.pdf --latex-engine=/Library/TeX/texbin/xelatex# tips：可以将该路径加入$PATH# 指定中英文字体pandoc -N -s --toc --smart --latex-engine=xelatex -V CJKmainfont='Kai' -V mainfont='Monaco' -V geometry:margin=1in hello-world.md -o output.pdfpandoc -N -s --toc --smart -V CJKmainfont='Songti SC' -V mainfont='Monaco' --variable sansfont="Monaco" --variable monofont="Monaco" --variable fontsize=26pt --latex-engine=xelatex -V geometry:margin=1in IPv6协议转发实验.md -o example14.pdf Mac 下的中文字体集 12345678910宋体仿宋 STFangsong宋体黑体 STHei宋体简体 Songti SC PingFang SC LingWai SC LiSong Pro LiHei Pro Libian SC Lantinghei TC Kaiti SC PDF with numbered sections and a custom LaTeX header 123pandoc -N --template=mytemplate.tex --variable mainfont="Palatino" --variable sansfont="Helvetica" --variable monofont="Menlo" --variable fontsize=12pt --variable version=1.17.2 MANUAL.txt --latex-engine=xelatex --toc -o example14.pdfpandoc -N -s --toc --smart -V CJKmainfont='Kai' -V mainfont='Monaco' --variable sansfont="Monaco" --variable monofont="Monaco" --variable fontsize=26pt --latex-engine=xelatex -V geometry:margin=1in hello-world.md -o example14.pdf Unix/Linux 系统下修改环境变量123sudo vi .bash_profile# 添加需要增加的环境变量PATH=$PATH:/Library/TeX/texbin/ 然后重新启动terminal即可 sublime 快捷键插入自定义字符串Preference-&gt; Key Bingding-&gt; 修改user settings 在其中加入自定义快捷键 123456&#123; "keys": ["alt+r"], "command": "insert_snippet", "args": &#123; "contents": "&lt;font color=red&gt;$&#123;1:&#125;$SELECTION&lt;/font&gt;$&#123;0&#125;" &#125; &#125;, 其中光标所在位置为${1:}$SELECTION所在地 树莓派开机自启动脚本12345678910111213141516171819202122232425#!/bin/sh### BEGIN INIT INFO# Provides: auto_start# Required-Start: $remote_fs# Required-Stop: $remote_fs# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: Start or stop the HTTP Proxy.### END INIT INFOcase $1 in start) # svnserve -d -r /home/pi/svn_repository python /home/pi/Documents/tips/auto_login.py python /home/pi/Documents/tips/start_note.py python /home/pi/Documents/tips/baidu_weather.py php5 /home/pi/Documents/tips/bind_dns/bind.php pi php5 /home/pi/Documents/tips/bind_dns/bind.php survey ;; stop) killall svnserve ;;*)echo "Usage: $0 (start|stop)";;esac 注：本意是想写一个可以开机自启动的脚本，脚本的目的是登录校园网，然后将本机的IP地址更新到自己的域名中，向linux机器添加开机自启动脚本的方法为： 123456789# 在/etc/init.d/文件夹下添加新的启动脚本，格式参考上面，注意需要加入BEGIN INIT INFO那一段注释，否则在加入启动项时会出现LSB不存在的errorsudo chmod +x 775 name# 给脚本足够运行权限sudo update-rc.d name defaults 95# 将自启动脚本name添加到自启动表项中，启动顺序为95，注意，需要使用网络的脚本顺序要大于90sudo update-rc.d -f name remove# 移除自启动项name 这样既可开机自启动该脚本了 但是在实际运行中发现并不能实现自动的登录以及域名解析的更新，分析了之后发现该脚本启动时间太早，机器还没有分到ip地址，无法完成网络请求，于是将该脚本加入到了/etc/rc.local自启动脚本中，linux系统的脚本启动顺序为： 123/etc/init.d/ init.d目录包含许多系统各种服务的启动和停止脚本。/etc/rc.local 脚本是在系统初始化级别脚本运行之后再执行的，因此可以安全地在里面添加你想在系统启动之后执行的脚本。 在rc.local文件中，exit 0之前加入我们的启动脚本 为了保证可以联网，我们在脚本中设置了一个死循环，重复登录直到登录成功 12345678910111213141516while True: try: f = urllib2.urlopen(url, post_data) # 这里完成了向登录页面发送登录POST请求的操作，只有这一步成功完成之后才能进行下一步的绑定域名脚本的执行，如果尚未分配到ip则会进入异常处理等待5秒继续尝试登录 content = f.read() # print content result=urllib.urlopen('http://baidu.com').read() print result print os.popen('sh /home/pi/Documents/bind.sh').read() # 在python中执行shell脚本的方法，这个函数可以输出脚本的输出信息 print "Network is Ready!" break except Exception , e: print e print "Network is not ready,Sleep 5s..." time.sleep(5) python 调用命令行os.popen这种调用方法可以输出脚本的输出信息,推荐使用 12import osos.popen('sh /home/pi/Documents/bind.sh').read() os.system 会输出一些奇怪的东西 12import osos.system("echo \"Hello World\"") 查看应用安装位置12345# 查看运行文件所在处which hexo# 查看应用安装位置whereis hexo]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[计算机系统结构]指令系统]]></title>
      <url>%2F2017%2F03%2F15%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%2F</url>
      <content type="text"><![CDATA[指令系统，寻址方式，内存映射，大端小端，哈夫曼编码，单地址指令，两地址指令 $$\sum_{i=1}^n a_i=0$$ 计算机系统的性能评价时钟频率指令执行速度 一种经典的表示运算速度的方法 MIPS(Million Instructions Per Second), GIPS, TIPS $$MIPS = \frac{指令条数}{执行时间\times 10^6} = \frac{Fz}{CPI} = IPC \times Fz$$ 其中: Fz为处理机的工作主频 CPI(Cycles Per Instruction)为每条指令所需的平均时钟周期数 IPC(Instruction Per Cycle)为每个时钟周期平均执行的指令条数 平均速度核心程序法峰值速度]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[密码学]古典密码]]></title>
      <url>%2F2017%2F03%2F14%2F%E5%AF%86%E7%A0%81%E5%AD%A6-%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%2F</url>
      <content type="text"><![CDATA[Description：移位密码，凯撒密码，置换密码 移位密码：加密:ci= (pi+K) mod 26解密:pi= (ci-K) mod 26 123密钥：整数， 1≤K ≤25 (26个英文字母)加密：明文P中的每个字母被它之后的第K个字母替代解密：密文C中的每个字母被它之前的第K个字母替代 凯撒密码1当 K=3时，该密码体制成为凯撒密码(Caesar Cipher) 在古罗马的战争(公元前54年)中使用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[密码学]-Exercise1]]></title>
      <url>%2F2017%2F03%2F14%2F%E5%AF%86%E7%A0%81%E5%AD%A6-Exercise1%2F</url>
      <content type="text"><![CDATA[密码学原理与实践（第二版）p32 1.5 1.16 1.21 1.26 1.29 1.30 1.5 使用穷尽密钥搜索方法破译如下利用移位密码加密的密文 BEEAK FYDJX UQYHY JIQRY HTYJI QFBQD UYJII KFUHC QD解：移位密码的加解密方法为：12加密：明文P中的每个字母被它之后的第K个字母替代解密：密文C中的每个字母被它之前的第K个字母替代 为了方便使用python编程完成遍历： 1234567import syspassword='BEEAK FYDJX UQYHY JIQRY HTYJI QFBQD UYJII KFUHC QD'password = password.replace(' ','')for i in range(0,26): for word in password: sys.stdout.write(chr(((ord(word) + i) - 65)%26 + 97)) sys.stdout.write('\n') 输出结果为： 12345678910111213141516171819202122232425260 beeakfydjxuqyhyjiqryhtyjiqfbqduyjiikfuhcqd1 addzjexciwtpxgxihpqxgsxihpeapctxihhjetgbpc2 zccyidwbhvsowfwhgopwfrwhgodzobswhggidsfaob3 ybbxhcvagurnvevgfnoveqvgfncynarvgffhcrezna4 xaawgbuzftqmudufemnudpufembxmzqufeegbqdymz5 wzzvfatyespltctedlmtcotedlawlypteddfapcxly6 vyyuezsxdroksbsdcklsbnsdckzvkxosdccezobwkx7 uxxtdyrwcqnjrarcbjkramrcbjyujwnrcbbdynavjw8 twwscxqvbpmiqzqbaijqzlqbaixtivmqbaacxmzuiv9 svvrbwpuaolhpypazhipykpazhwshulpazzbwlythu10 ruuqavotznkgoxozyghoxjozygvrgtkozyyavkxsgt11 qttpzunsymjfnwnyxfgnwinyxfuqfsjnyxxzujwrfs12 pssoytmrxliemvmxwefmvhmxwetperimxwwytivqer13 orrnxslqwkhdlulwvdeluglwvdsodqhlwvvxshupdq14 nqqmwrkpvjgcktkvucdktfkvucrncpgkvuuwrgtocp15 mpplvqjouifbjsjutbcjsejutbqmbofjuttvqfsnbo16 lookupintheairitsabirditsaplaneitssuperman17 knnjtohmsgdzhqhsrzahqchsrzokzmdhsrrtodqlzm18 jmmisnglrfcygpgrqyzgpbgrqynjylcgrqqsncpkyl19 illhrmfkqebxfofqpxyfoafqpxmixkbfqpprmbojxk20 hkkgqlejpdawenepowxenzepowlhwjaepooqlaniwj21 gjjfpkdioczvdmdonvwdmydonvkgvizdonnpkzmhvi22 fiieojchnbyuclcnmuvclxcnmujfuhycnmmojylguh23 ehhdnibgmaxtbkbmltubkwbmltietgxbmllnixkftg24 dggcmhaflzwsajalkstajvalkshdsfwalkkmhwjesf25 cffblgzekyvrzizkjrsziuzkjrgcrevzkjjlgvidre 查看输出的26条结果，发现lookup in the air its a bird its a plane its superman是其中有意义的语句，相应秘钥为K=16]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[搜索引擎]性能评价]]></title>
      <url>%2F2017%2F03%2F14%2F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E-%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7%2F</url>
      <content type="text"><![CDATA[搜索引擎性能评价的目的 对用户而言： 信息获取渠道 对搜索引擎广告商而言 对搜索技术研究人员而言 对搜索引擎服务提供者 从较差查询样例中学习 链接锚本重定向问题 清华美院 团、派 搜索引擎性能评价流程1.1 搜索引擎性能评价的对象网络服务提供商的属性市场占用率、 网络信息检索工具属性网络数据环境、用户群体 搜索引擎运行效果 响应时间 耗费的硬件资源 是否满足用户的信息需求 用户获取信息耗费的时间成本？ 根据用户的需求调整响应时间和查询质量？ 1.2 搜索引擎性能评价的Cranfield体系 黑箱评价方式：给定标准输入情况下，看系统输出与标准输出的差异 输入:语料库，查询样例、相关性标注 优势：复用性（一次标注，多次使用） 语料库采集信息检索系统：提供固定的语料库集合，集合规模适当，数据质量可靠 商业搜索引擎：不提供固定的语料库集合，评价数据抓取子系统性能 查询样例集合构建 用户查询规模庞大 核心问题：如何采样：真实性，精确性，全面性 查询采样的真实性：反映用户实际需求来源：用户查询日志行为（日志隐私保护）、公开数据资源 查询采样的精确性：减少数据标注困难查询采样的全面性：综合评价各方面性能少量查询样例代表大多数需求采样依据：内容类别、热门程度、需求类型 查询信息需求决定了用户使用搜索引擎的满意度，数据环境复杂用户意图难以琢磨 搜索引擎用户信息需求分布：导航类：查询某个已知存在的资源，页面 主页，考试资源等等信息类：查询与某个主题相关的关键信息资源 获取相关信息，没有确定查询目标， 香港股市，，，事务类：查找与完成某个特定任务相关的资源 垂直搜索引擎服务对象 如：xxx下载， 保证采样全面性：查询热门程度（冷热保证） 查询信息需求（2：5：3） 结果相关性标注内容相关≠关键资源 相关性结果的共性要求： 结果提供的学习时新、真实可靠 结果的标题和摘要应当方便阅读并有效引导用户阅读 以信息需求类别为指导 Pooling 方法文本语料=》查询样例集 》 手工相关性标注 准确率/召回率准确率：找到的是否准确召回率：找到的是否全面 信息检索强调序列的关系 搜索引擎性能指标设计AP：平均准确率搜索引擎用户行为的特殊性前10个结果（85%） 搜索引擎用户信息需求的差异性• 导航类信息需求的用户仅关注特定检索目标• 信息类信息需求的用户关注全面而权威的信息• 事务类信息需求的用户关注自己的任务是否可以顺利完成。 首位相关结果倒数(Reciprocal Rank)$$RR = \frac{1}{Rank(1)}$$ 适用于导航类型的查询信息需求（ 用户在找到搜索目标前需要浏览多少结果？ ） 前N位准确率(Precision@N)适用于信息类型的查询信息需求（ 结果列表中多大比例信息能够满足用户需求？ ） 前N位成功率(Success@N)适用于事务类型的查询信息需求（ 用户是否能够利用给出的结果完成自己所关注的事务？ ） 其他 NDCG@N:• Normalized Discounted Cumulative Gain• 对结果进行多级相关性标注时适用• ERR: Expected Reciprocal Rank• Supported by Yahoo! and Google• 可以获取用户行为数据时适用• B-pref: Binary preference• 相关性标注不完整时适用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello Hexo]]></title>
      <url>%2F2017%2F03%2F14%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy 草稿草稿相当于很多博客都有的“私密文章”功能。 1$ hexo new draft "new draft" 会在source/_drafts目录下生成一个new-draft.md文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到_drafts目录之中。 如果你希望强行预览草稿，更改配置文件： 1render_drafts: true 或者，如下方式启动server： 1$ hexo server --drafts 下面这条命令可以把草稿变成文章，或者页面： 1$ hexo publish [layout] &lt;filename&gt; More info: Deployment mathjax在blog文件夹中执行： 1$ hexo math install 在_config.yml文件中添加： 12plugins:- hexo-math 使用 1Simple inline $a = b + c$. 效果： Simple inline $a = b + c$. MathJax Block: 1234$$\frac&#123;\partial u&#125;&#123;\partial t&#125;= h^2 \left( \frac&#123;\partial^2 u&#125;&#123;\partial x^2&#125; +\frac&#123;\partial^2 u&#125;&#123;\partial y^2&#125; +\frac&#123;\partial^2 u&#125;&#123;\partial z^2&#125;\right)$$ 效果：$$\frac{\partial u}{\partial t}= h^2 \left( \frac{\partial^2 u}{\partial x^2} +\frac{\partial^2 u}{\partial y^2} +\frac{\partial^2 u}{\partial z^2}\right)$$ 为Hexo Next博客添加关键词功能修改文件：themes\next\layout_partials\head.swig 1234567&#123;% if page.keywords %&#125; &lt;meta name="keywords" content="&#123;&#123; page.keywords &#125;&#125;" /&gt;&#123;% elif page.tags and page.tags.length %&#125; &lt;meta name="keywords" content="&#123;% for tag in page.tags %&#125;&#123;&#123; tag.name &#125;&#125;,&#123;% endfor %&#125;" /&gt;&#123;% elif theme.keywords %&#125; &lt;meta name="keywords" content="&#123;&#123; theme.keywords &#125;&#125;" /&gt;&#123;% endif %&#125; 修改内容：35行左右，将原来的设置ketwords的代码覆盖即可 1234567&#123;% if page.keywords and page.keywords.length %&#125; &lt;meta name="keywords" content="&#123;% for key in page.keywords %&#125;&#123;&#123; key &#125;&#125;,&#123;% endfor %&#125;" /&gt;&#123;% elif page.tags and page.tags.length %&#125; &lt;meta name="keywords" content="&#123;% for tag in page.tags %&#125;&#123;&#123; tag.name &#125;&#125;,&#123;% endfor %&#125;" /&gt;&#123;% elif theme.keywords %&#125; &lt;meta name="keywords" content="&#123;&#123; theme.keywords &#125;&#125;" /&gt;&#123;% endif %&#125;]]></content>
    </entry>

    
  
  
</search>
